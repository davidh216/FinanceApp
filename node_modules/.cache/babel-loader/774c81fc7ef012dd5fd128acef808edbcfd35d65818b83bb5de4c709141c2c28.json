{"ast":null,"code":"import { getDocs, getDoc, updateDoc, deleteDoc, onSnapshot, addDoc, serverTimestamp, Timestamp, collection, doc } from 'firebase/firestore';\nimport { db } from '../config/firebase';\nclass MockBudgetService {\n  constructor() {\n    this.budgets = [];\n    this.alerts = [];\n    this.generateMockBudgets();\n  }\n  generateMockBudgets() {\n    const budgetData = [{\n      category: 'Food & Dining',\n      amount: 800,\n      spent: 720,\n      // 90% - on track\n      period: 'month'\n    }, {\n      category: 'Transportation',\n      amount: 400,\n      spent: 450,\n      // 112.5% - over budget\n      period: 'month'\n    }, {\n      category: 'Shopping',\n      amount: 600,\n      spent: 480,\n      // 80% - on track\n      period: 'month'\n    }, {\n      category: 'Entertainment',\n      amount: 300,\n      spent: 330,\n      // 110% - over budget\n      period: 'month'\n    }, {\n      category: 'Utilities',\n      amount: 250,\n      spent: 200,\n      // 80% - on track\n      period: 'month'\n    }, {\n      category: 'Healthcare',\n      amount: 150,\n      spent: 180,\n      // 120% - over budget\n      period: 'month'\n    }, {\n      category: 'Travel',\n      amount: 1200,\n      spent: 900,\n      // 75% - on track\n      period: 'quarter'\n    }, {\n      category: 'Home Improvement',\n      amount: 2000,\n      spent: 2200,\n      // 110% - over budget\n      period: 'quarter'\n    }];\n    budgetData.forEach((data, index) => {\n      this.budgets.push({\n        id: `budget-${index}`,\n        userId: 'mock-user',\n        category: data.category,\n        amount: data.amount,\n        period: data.period,\n        startDate: new Date().toISOString(),\n        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n        // 30 days from now\n        spent: data.spent,\n        remaining: data.amount - data.spent,\n        alerts: [],\n        isActive: true,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      });\n    });\n  }\n  async createBudget(budgetData) {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    const budget = {\n      ...budgetData,\n      id: `budget-${Date.now()}`,\n      userId: 'mock-user',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n    this.budgets.push(budget);\n    return budget;\n  }\n  async getBudgets(userId) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    return this.budgets.filter(budget => budget.userId === userId);\n  }\n  async getBudget(id) {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    return this.budgets.find(budget => budget.id === id) || null;\n  }\n  async updateBudget(id, updates) {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    const index = this.budgets.findIndex(budget => budget.id === id);\n    if (index === -1) {\n      throw new Error('Budget not found');\n    }\n    this.budgets[index] = {\n      ...this.budgets[index],\n      ...updates,\n      updatedAt: new Date().toISOString()\n    };\n    return this.budgets[index];\n  }\n  async deleteBudget(id) {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    const index = this.budgets.findIndex(budget => budget.id === id);\n    if (index === -1) {\n      return false;\n    }\n    this.budgets.splice(index, 1);\n    return true;\n  }\n  async getBudgetProgress(budgetId) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    const budget = this.budgets.find(b => b.id === budgetId);\n    if (!budget) {\n      throw new Error('Budget not found');\n    }\n    const percentageUsed = budget.spent / budget.amount * 100;\n    const isOverBudget = budget.spent > budget.amount;\n    const daysRemaining = Math.ceil((new Date(budget.endDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24));\n    const projectedSpending = budget.spent + budget.spent / (30 - daysRemaining) * daysRemaining;\n    return {\n      budgetId,\n      spent: budget.spent,\n      remaining: budget.remaining,\n      percentageUsed,\n      isOverBudget,\n      daysRemaining: Math.max(0, daysRemaining),\n      projectedSpending\n    };\n  }\n  async getBudgetSummary(userId) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    const userBudgets = this.budgets.filter(budget => budget.userId === userId && budget.isActive);\n    const totalBudgeted = userBudgets.reduce((sum, budget) => sum + budget.amount, 0);\n    const totalSpent = userBudgets.reduce((sum, budget) => sum + budget.spent, 0);\n    const totalRemaining = totalBudgeted - totalSpent;\n    const overBudgetCategories = userBudgets.filter(budget => budget.spent > budget.amount).map(budget => budget.category);\n    const upcomingAlerts = this.alerts.filter(alert => userBudgets.some(budget => budget.id === alert.id && !alert.triggered));\n    return {\n      totalBudgets: userBudgets.length,\n      totalBudgeted,\n      totalSpent,\n      totalRemaining,\n      overBudgetCategories,\n      upcomingAlerts\n    };\n  }\n  async calculateBudgetSpending(budgetId, transactions) {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    const budget = this.budgets.find(b => b.id === budgetId);\n    if (!budget) {\n      return 0;\n    }\n\n    // Filter transactions by category and date range\n    const relevantTransactions = transactions.filter(tx => tx.category === budget.category && new Date(tx.date) >= new Date(budget.startDate) && new Date(tx.date) <= new Date(budget.endDate) && tx.amount < 0 // Only expenses\n    );\n    return Math.abs(relevantTransactions.reduce((sum, tx) => sum + tx.amount, 0));\n  }\n  async createBudgetAlert(budgetId, alertData) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    const alert = {\n      ...alertData,\n      id: `alert-${Date.now()}`,\n      createdAt: new Date().toISOString()\n    };\n    this.alerts.push(alert);\n    return alert;\n  }\n  async getBudgetAlerts(budgetId) {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    return this.alerts.filter(alert => alert.id === budgetId);\n  }\n  async updateBudgetAlert(alertId, updates) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    const index = this.alerts.findIndex(alert => alert.id === alertId);\n    if (index === -1) {\n      throw new Error('Alert not found');\n    }\n    this.alerts[index] = {\n      ...this.alerts[index],\n      ...updates\n    };\n    return this.alerts[index];\n  }\n  subscribeToBudgets(userId, callback) {\n    // Mock subscription - just call once with current data\n    setTimeout(() => {\n      const userBudgets = this.budgets.filter(budget => budget.userId === userId);\n      callback(userBudgets);\n    }, 100);\n\n    // Return unsubscribe function\n    return () => {};\n  }\n  subscribeToBudgetProgress(budgetId, callback) {\n    // Mock subscription - just call once with current data\n    setTimeout(async () => {\n      const progress = await this.getBudgetProgress(budgetId);\n      callback(progress);\n    }, 100);\n\n    // Return unsubscribe function\n    return () => {};\n  }\n}\nclass FirebaseBudgetService {\n  constructor(config, userId) {\n    this.config = void 0;\n    this.userId = void 0;\n    this.config = config;\n    this.userId = userId;\n  }\n  getUserBudgetsCollection() {\n    return collection(db, 'users', this.userId, 'budgets');\n  }\n  getBudgetDocRef(budgetId) {\n    return doc(db, 'users', this.userId, 'budgets', budgetId);\n  }\n  convertTimestamp(timestamp) {\n    if (typeof timestamp === 'string') return timestamp;\n    return timestamp.toDate().toISOString();\n  }\n  convertToTimestamp(dateString) {\n    return Timestamp.fromDate(new Date(dateString));\n  }\n  convertFirestoreToBudget(doc) {\n    const data = doc.data();\n    return {\n      id: doc.id,\n      userId: data.userId,\n      category: data.category,\n      amount: data.amount,\n      period: data.period,\n      startDate: this.convertTimestamp(data.startDate),\n      endDate: this.convertTimestamp(data.endDate),\n      spent: data.spent || 0,\n      remaining: data.remaining || data.amount,\n      alerts: data.alerts || [],\n      isActive: data.isActive !== false,\n      createdAt: this.convertTimestamp(data.createdAt || serverTimestamp()),\n      updatedAt: this.convertTimestamp(data.updatedAt || serverTimestamp())\n    };\n  }\n  async createBudget(budgetData) {\n    try {\n      const budgetsRef = this.getUserBudgetsCollection();\n      const budgetDoc = {\n        ...budgetData,\n        userId: this.userId,\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp()\n      };\n      const docRef = await addDoc(budgetsRef, budgetDoc);\n      const budgetSnap = await getDoc(docRef);\n      if (budgetSnap.exists()) {\n        return this.convertFirestoreToBudget(budgetSnap);\n      }\n      throw new Error('Failed to create budget');\n    } catch (error) {\n      console.error('Error creating budget:', error);\n      throw new Error('Failed to create budget');\n    }\n  }\n  async getBudgets(userId) {\n    try {\n      const budgetsRef = this.getUserBudgetsCollection();\n      const querySnapshot = await getDocs(budgetsRef);\n      return querySnapshot.docs.map(doc => this.convertFirestoreToBudget(doc));\n    } catch (error) {\n      console.error('Error fetching budgets:', error);\n      throw new Error('Failed to fetch budgets');\n    }\n  }\n  async getBudget(id) {\n    try {\n      const budgetRef = this.getBudgetDocRef(id);\n      const budgetSnap = await getDoc(budgetRef);\n      if (budgetSnap.exists()) {\n        return this.convertFirestoreToBudget(budgetSnap);\n      }\n      return null;\n    } catch (error) {\n      console.error('Error fetching budget:', error);\n      throw new Error('Failed to fetch budget');\n    }\n  }\n  async updateBudget(id, updates) {\n    try {\n      const budgetRef = this.getBudgetDocRef(id);\n      const updatedBudget = {\n        ...updates,\n        updatedAt: serverTimestamp()\n      };\n      await updateDoc(budgetRef, updatedBudget);\n\n      // Fetch updated budget\n      const budgetSnap = await getDoc(budgetRef);\n      if (budgetSnap.exists()) {\n        return this.convertFirestoreToBudget(budgetSnap);\n      }\n      throw new Error('Budget not found');\n    } catch (error) {\n      console.error('Error updating budget:', error);\n      throw new Error('Failed to update budget');\n    }\n  }\n  async deleteBudget(id) {\n    try {\n      const budgetRef = this.getBudgetDocRef(id);\n      await deleteDoc(budgetRef);\n      return true;\n    } catch (error) {\n      console.error('Error deleting budget:', error);\n      throw new Error('Failed to delete budget');\n    }\n  }\n  async getBudgetProgress(budgetId) {\n    try {\n      const budget = await this.getBudget(budgetId);\n      if (!budget) {\n        throw new Error('Budget not found');\n      }\n      const percentageUsed = budget.spent / budget.amount * 100;\n      const isOverBudget = budget.spent > budget.amount;\n      const daysRemaining = Math.ceil((new Date(budget.endDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24));\n      const projectedSpending = budget.spent + budget.spent / (30 - daysRemaining) * daysRemaining;\n      return {\n        budgetId,\n        spent: budget.spent,\n        remaining: budget.remaining,\n        percentageUsed,\n        isOverBudget,\n        daysRemaining: Math.max(0, daysRemaining),\n        projectedSpending\n      };\n    } catch (error) {\n      console.error('Error calculating budget progress:', error);\n      throw new Error('Failed to calculate budget progress');\n    }\n  }\n  async getBudgetSummary(userId) {\n    try {\n      const budgets = await this.getBudgets(userId);\n      const activeBudgets = budgets.filter(budget => budget.isActive);\n      const totalBudgeted = activeBudgets.reduce((sum, budget) => sum + budget.amount, 0);\n      const totalSpent = activeBudgets.reduce((sum, budget) => sum + budget.spent, 0);\n      const totalRemaining = totalBudgeted - totalSpent;\n      const overBudgetCategories = activeBudgets.filter(budget => budget.spent > budget.amount).map(budget => budget.category);\n      const upcomingAlerts = activeBudgets.flatMap(budget => budget.alerts.filter(alert => !alert.triggered));\n      return {\n        totalBudgets: activeBudgets.length,\n        totalBudgeted,\n        totalSpent,\n        totalRemaining,\n        overBudgetCategories,\n        upcomingAlerts\n      };\n    } catch (error) {\n      console.error('Error calculating budget summary:', error);\n      throw new Error('Failed to calculate budget summary');\n    }\n  }\n  async calculateBudgetSpending(budgetId, transactions) {\n    try {\n      const budget = await this.getBudget(budgetId);\n      if (!budget) {\n        return 0;\n      }\n\n      // Filter transactions by category and date range\n      const relevantTransactions = transactions.filter(tx => tx.category === budget.category && new Date(tx.date) >= new Date(budget.startDate) && new Date(tx.date) <= new Date(budget.endDate) && tx.amount < 0 // Only expenses\n      );\n      return Math.abs(relevantTransactions.reduce((sum, tx) => sum + tx.amount, 0));\n    } catch (error) {\n      console.error('Error calculating budget spending:', error);\n      throw new Error('Failed to calculate budget spending');\n    }\n  }\n  async createBudgetAlert(budgetId, alertData) {\n    try {\n      const budget = await this.getBudget(budgetId);\n      if (!budget) {\n        throw new Error('Budget not found');\n      }\n      const alert = {\n        ...alertData,\n        id: `alert-${Date.now()}`,\n        createdAt: new Date().toISOString()\n      };\n\n      // Add alert to budget\n      const updatedAlerts = [...budget.alerts, alert];\n      await this.updateBudget(budgetId, {\n        alerts: updatedAlerts\n      });\n      return alert;\n    } catch (error) {\n      console.error('Error creating budget alert:', error);\n      throw new Error('Failed to create budget alert');\n    }\n  }\n  async getBudgetAlerts(budgetId) {\n    try {\n      const budget = await this.getBudget(budgetId);\n      return (budget === null || budget === void 0 ? void 0 : budget.alerts) || [];\n    } catch (error) {\n      console.error('Error fetching budget alerts:', error);\n      throw new Error('Failed to fetch budget alerts');\n    }\n  }\n  async updateBudgetAlert(alertId, updates) {\n    try {\n      // Find budget containing this alert\n      const budgets = await this.getBudgets(this.userId);\n      const budgetWithAlert = budgets.find(budget => budget.alerts.some(alert => alert.id === alertId));\n      if (!budgetWithAlert) {\n        throw new Error('Alert not found');\n      }\n\n      // Update the alert\n      const updatedAlerts = budgetWithAlert.alerts.map(alert => alert.id === alertId ? {\n        ...alert,\n        ...updates\n      } : alert);\n      await this.updateBudget(budgetWithAlert.id, {\n        alerts: updatedAlerts\n      });\n      const updatedAlert = updatedAlerts.find(alert => alert.id === alertId);\n      if (!updatedAlert) {\n        throw new Error('Failed to update alert');\n      }\n      return updatedAlert;\n    } catch (error) {\n      console.error('Error updating budget alert:', error);\n      throw new Error('Failed to update budget alert');\n    }\n  }\n  subscribeToBudgets(userId, callback) {\n    const budgetsRef = this.getUserBudgetsCollection();\n    return onSnapshot(budgetsRef, snapshot => {\n      const budgets = snapshot.docs.map(doc => this.convertFirestoreToBudget(doc));\n      callback(budgets);\n    });\n  }\n  subscribeToBudgetProgress(budgetId, callback) {\n    const budgetRef = this.getBudgetDocRef(budgetId);\n    return onSnapshot(budgetRef, async snapshot => {\n      if (snapshot.exists()) {\n        const progress = await this.getBudgetProgress(budgetId);\n        callback(progress);\n      }\n    });\n  }\n}\nexport function createBudgetService(config, userId) {\n  if (config.useMockData) {\n    return new MockBudgetService();\n  } else {\n    if (!userId) {\n      throw new Error('User ID is required for Firebase BudgetService');\n    }\n    return new FirebaseBudgetService(config, userId);\n  }\n}\n\n// Export classes for testing\nexport { MockBudgetService, FirebaseBudgetService };\n\n// Default export for convenience\nexport default createBudgetService;","map":{"version":3,"names":["getDocs","getDoc","updateDoc","deleteDoc","onSnapshot","addDoc","serverTimestamp","Timestamp","collection","doc","db","MockBudgetService","constructor","budgets","alerts","generateMockBudgets","budgetData","category","amount","spent","period","forEach","data","index","push","id","userId","startDate","Date","toISOString","endDate","now","remaining","isActive","createdAt","updatedAt","createBudget","Promise","resolve","setTimeout","budget","getBudgets","filter","getBudget","find","updateBudget","updates","findIndex","Error","deleteBudget","splice","getBudgetProgress","budgetId","b","percentageUsed","isOverBudget","daysRemaining","Math","ceil","getTime","projectedSpending","max","getBudgetSummary","userBudgets","totalBudgeted","reduce","sum","totalSpent","totalRemaining","overBudgetCategories","map","upcomingAlerts","alert","some","triggered","totalBudgets","length","calculateBudgetSpending","transactions","relevantTransactions","tx","date","abs","createBudgetAlert","alertData","getBudgetAlerts","updateBudgetAlert","alertId","subscribeToBudgets","callback","subscribeToBudgetProgress","progress","FirebaseBudgetService","config","getUserBudgetsCollection","getBudgetDocRef","convertTimestamp","timestamp","toDate","convertToTimestamp","dateString","fromDate","convertFirestoreToBudget","budgetsRef","budgetDoc","docRef","budgetSnap","exists","error","console","querySnapshot","docs","budgetRef","updatedBudget","activeBudgets","flatMap","updatedAlerts","budgetWithAlert","updatedAlert","snapshot","createBudgetService","useMockData"],"sources":["C:/Users/X2DHHWAN/Desktop/Finance-App/src/services/budgetService.ts"],"sourcesContent":["import { Budget, BudgetProgress, BudgetSummary, BudgetAlert, TimePeriod } from '../types/financial';\r\nimport { \r\n  getDocs, \r\n  getDoc, \r\n  setDoc, \r\n  updateDoc, \r\n  deleteDoc, \r\n  query, \r\n  where, \r\n  orderBy, \r\n  limit, \r\n  onSnapshot,\r\n  addDoc,\r\n  serverTimestamp,\r\n  Timestamp,\r\n  QueryConstraint,\r\n  DocumentData,\r\n  collection,\r\n  doc\r\n} from 'firebase/firestore';\r\nimport { db } from '../config/firebase';\r\n\r\nexport interface BudgetServiceConfig {\r\n  useMockData: boolean;\r\n  apiBaseUrl?: string;\r\n  apiKey?: string;\r\n}\r\n\r\nexport interface BudgetServiceResponse<T> {\r\n  data: T;\r\n  error?: string;\r\n  loading: boolean;\r\n}\r\n\r\nexport interface BudgetService {\r\n  // Budget operations\r\n  createBudget(budget: Omit<Budget, 'id' | 'userId' | 'createdAt' | 'updatedAt'>): Promise<Budget>;\r\n  getBudgets(userId: string): Promise<Budget[]>;\r\n  getBudget(id: string): Promise<Budget | null>;\r\n  updateBudget(id: string, updates: Partial<Budget>): Promise<Budget>;\r\n  deleteBudget(id: string): Promise<boolean>;\r\n  \r\n  // Budget progress and analytics\r\n  getBudgetProgress(budgetId: string): Promise<BudgetProgress>;\r\n  getBudgetSummary(userId: string): Promise<BudgetSummary>;\r\n  calculateBudgetSpending(budgetId: string, transactions: any[]): Promise<number>;\r\n  \r\n  // Budget alerts\r\n  createBudgetAlert(budgetId: string, alert: Omit<BudgetAlert, 'id' | 'createdAt'>): Promise<BudgetAlert>;\r\n  getBudgetAlerts(budgetId: string): Promise<BudgetAlert[]>;\r\n  updateBudgetAlert(alertId: string, updates: Partial<BudgetAlert>): Promise<BudgetAlert>;\r\n  \r\n  // Real-time subscriptions\r\n  subscribeToBudgets(userId: string, callback: (budgets: Budget[]) => void): () => void;\r\n  subscribeToBudgetProgress(budgetId: string, callback: (progress: BudgetProgress) => void): () => void;\r\n}\r\n\r\nclass MockBudgetService implements BudgetService {\r\n  private budgets: Budget[] = [];\r\n  private alerts: BudgetAlert[] = [];\r\n\r\n  constructor() {\r\n    this.generateMockBudgets();\r\n  }\r\n\r\n  private generateMockBudgets(): void {\r\n    const budgetData = [\r\n      {\r\n        category: 'Food & Dining',\r\n        amount: 800,\r\n        spent: 720, // 90% - on track\r\n        period: 'month' as TimePeriod,\r\n      },\r\n      {\r\n        category: 'Transportation',\r\n        amount: 400,\r\n        spent: 450, // 112.5% - over budget\r\n        period: 'month' as TimePeriod,\r\n      },\r\n      {\r\n        category: 'Shopping',\r\n        amount: 600,\r\n        spent: 480, // 80% - on track\r\n        period: 'month' as TimePeriod,\r\n      },\r\n      {\r\n        category: 'Entertainment',\r\n        amount: 300,\r\n        spent: 330, // 110% - over budget\r\n        period: 'month' as TimePeriod,\r\n      },\r\n      {\r\n        category: 'Utilities',\r\n        amount: 250,\r\n        spent: 200, // 80% - on track\r\n        period: 'month' as TimePeriod,\r\n      },\r\n      {\r\n        category: 'Healthcare',\r\n        amount: 150,\r\n        spent: 180, // 120% - over budget\r\n        period: 'month' as TimePeriod,\r\n      },\r\n      {\r\n        category: 'Travel',\r\n        amount: 1200,\r\n        spent: 900, // 75% - on track\r\n        period: 'quarter' as TimePeriod,\r\n      },\r\n      {\r\n        category: 'Home Improvement',\r\n        amount: 2000,\r\n        spent: 2200, // 110% - over budget\r\n        period: 'quarter' as TimePeriod,\r\n      },\r\n    ];\r\n    \r\n    budgetData.forEach((data, index) => {\r\n      this.budgets.push({\r\n        id: `budget-${index}`,\r\n        userId: 'mock-user',\r\n        category: data.category,\r\n        amount: data.amount,\r\n        period: data.period,\r\n        startDate: new Date().toISOString(),\r\n        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days from now\r\n        spent: data.spent,\r\n        remaining: data.amount - data.spent,\r\n        alerts: [],\r\n        isActive: true,\r\n        createdAt: new Date().toISOString(),\r\n        updatedAt: new Date().toISOString(),\r\n      });\r\n    });\r\n  }\r\n\r\n  async createBudget(budgetData: Omit<Budget, 'id' | 'userId' | 'createdAt' | 'updatedAt'>): Promise<Budget> {\r\n    await new Promise(resolve => setTimeout(resolve, 200));\r\n    \r\n    const budget: Budget = {\r\n      ...budgetData,\r\n      id: `budget-${Date.now()}`,\r\n      userId: 'mock-user',\r\n      createdAt: new Date().toISOString(),\r\n      updatedAt: new Date().toISOString(),\r\n    };\r\n    \r\n    this.budgets.push(budget);\r\n    return budget;\r\n  }\r\n\r\n  async getBudgets(userId: string): Promise<Budget[]> {\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    return this.budgets.filter(budget => budget.userId === userId);\r\n  }\r\n\r\n  async getBudget(id: string): Promise<Budget | null> {\r\n    await new Promise(resolve => setTimeout(resolve, 50));\r\n    return this.budgets.find(budget => budget.id === id) || null;\r\n  }\r\n\r\n  async updateBudget(id: string, updates: Partial<Budget>): Promise<Budget> {\r\n    await new Promise(resolve => setTimeout(resolve, 200));\r\n    \r\n    const index = this.budgets.findIndex(budget => budget.id === id);\r\n    if (index === -1) {\r\n      throw new Error('Budget not found');\r\n    }\r\n    \r\n    this.budgets[index] = {\r\n      ...this.budgets[index],\r\n      ...updates,\r\n      updatedAt: new Date().toISOString(),\r\n    };\r\n    \r\n    return this.budgets[index];\r\n  }\r\n\r\n  async deleteBudget(id: string): Promise<boolean> {\r\n    await new Promise(resolve => setTimeout(resolve, 200));\r\n    \r\n    const index = this.budgets.findIndex(budget => budget.id === id);\r\n    if (index === -1) {\r\n      return false;\r\n    }\r\n    \r\n    this.budgets.splice(index, 1);\r\n    return true;\r\n  }\r\n\r\n  async getBudgetProgress(budgetId: string): Promise<BudgetProgress> {\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    \r\n    const budget = this.budgets.find(b => b.id === budgetId);\r\n    if (!budget) {\r\n      throw new Error('Budget not found');\r\n    }\r\n    \r\n    const percentageUsed = (budget.spent / budget.amount) * 100;\r\n    const isOverBudget = budget.spent > budget.amount;\r\n    const daysRemaining = Math.ceil((new Date(budget.endDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24));\r\n    const projectedSpending = budget.spent + (budget.spent / (30 - daysRemaining)) * daysRemaining;\r\n    \r\n    return {\r\n      budgetId,\r\n      spent: budget.spent,\r\n      remaining: budget.remaining,\r\n      percentageUsed,\r\n      isOverBudget,\r\n      daysRemaining: Math.max(0, daysRemaining),\r\n      projectedSpending,\r\n    };\r\n  }\r\n\r\n  async getBudgetSummary(userId: string): Promise<BudgetSummary> {\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    \r\n    const userBudgets = this.budgets.filter(budget => budget.userId === userId && budget.isActive);\r\n    const totalBudgeted = userBudgets.reduce((sum, budget) => sum + budget.amount, 0);\r\n    const totalSpent = userBudgets.reduce((sum, budget) => sum + budget.spent, 0);\r\n    const totalRemaining = totalBudgeted - totalSpent;\r\n    const overBudgetCategories = userBudgets\r\n      .filter(budget => budget.spent > budget.amount)\r\n      .map(budget => budget.category);\r\n    \r\n    const upcomingAlerts = this.alerts.filter(alert => \r\n      userBudgets.some(budget => budget.id === alert.id && !alert.triggered)\r\n    );\r\n    \r\n    return {\r\n      totalBudgets: userBudgets.length,\r\n      totalBudgeted,\r\n      totalSpent,\r\n      totalRemaining,\r\n      overBudgetCategories,\r\n      upcomingAlerts,\r\n    };\r\n  }\r\n\r\n  async calculateBudgetSpending(budgetId: string, transactions: any[]): Promise<number> {\r\n    await new Promise(resolve => setTimeout(resolve, 50));\r\n    \r\n    const budget = this.budgets.find(b => b.id === budgetId);\r\n    if (!budget) {\r\n      return 0;\r\n    }\r\n    \r\n    // Filter transactions by category and date range\r\n    const relevantTransactions = transactions.filter(tx => \r\n      tx.category === budget.category &&\r\n      new Date(tx.date) >= new Date(budget.startDate) &&\r\n      new Date(tx.date) <= new Date(budget.endDate) &&\r\n      tx.amount < 0 // Only expenses\r\n    );\r\n    \r\n    return Math.abs(relevantTransactions.reduce((sum, tx) => sum + tx.amount, 0));\r\n  }\r\n\r\n  async createBudgetAlert(budgetId: string, alertData: Omit<BudgetAlert, 'id' | 'createdAt'>): Promise<BudgetAlert> {\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    \r\n    const alert: BudgetAlert = {\r\n      ...alertData,\r\n      id: `alert-${Date.now()}`,\r\n      createdAt: new Date().toISOString(),\r\n    };\r\n    \r\n    this.alerts.push(alert);\r\n    return alert;\r\n  }\r\n\r\n  async getBudgetAlerts(budgetId: string): Promise<BudgetAlert[]> {\r\n    await new Promise(resolve => setTimeout(resolve, 50));\r\n    return this.alerts.filter(alert => alert.id === budgetId);\r\n  }\r\n\r\n  async updateBudgetAlert(alertId: string, updates: Partial<BudgetAlert>): Promise<BudgetAlert> {\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    \r\n    const index = this.alerts.findIndex(alert => alert.id === alertId);\r\n    if (index === -1) {\r\n      throw new Error('Alert not found');\r\n    }\r\n    \r\n    this.alerts[index] = {\r\n      ...this.alerts[index],\r\n      ...updates,\r\n    };\r\n    \r\n    return this.alerts[index];\r\n  }\r\n\r\n  subscribeToBudgets(userId: string, callback: (budgets: Budget[]) => void): () => void {\r\n    // Mock subscription - just call once with current data\r\n    setTimeout(() => {\r\n      const userBudgets = this.budgets.filter(budget => budget.userId === userId);\r\n      callback(userBudgets);\r\n    }, 100);\r\n    \r\n    // Return unsubscribe function\r\n    return () => {};\r\n  }\r\n\r\n  subscribeToBudgetProgress(budgetId: string, callback: (progress: BudgetProgress) => void): () => void {\r\n    // Mock subscription - just call once with current data\r\n    setTimeout(async () => {\r\n      const progress = await this.getBudgetProgress(budgetId);\r\n      callback(progress);\r\n    }, 100);\r\n    \r\n    // Return unsubscribe function\r\n    return () => {};\r\n  }\r\n}\r\n\r\nclass FirebaseBudgetService implements BudgetService {\r\n  private config: BudgetServiceConfig;\r\n  private userId: string;\r\n\r\n  constructor(config: BudgetServiceConfig, userId: string) {\r\n    this.config = config;\r\n    this.userId = userId;\r\n  }\r\n\r\n  private getUserBudgetsCollection() {\r\n    return collection(db, 'users', this.userId, 'budgets');\r\n  }\r\n\r\n  private getBudgetDocRef(budgetId: string) {\r\n    return doc(db, 'users', this.userId, 'budgets', budgetId);\r\n  }\r\n\r\n  private convertTimestamp(timestamp: Timestamp | string): string {\r\n    if (typeof timestamp === 'string') return timestamp;\r\n    return timestamp.toDate().toISOString();\r\n  }\r\n\r\n  private convertToTimestamp(dateString: string): Timestamp {\r\n    return Timestamp.fromDate(new Date(dateString));\r\n  }\r\n\r\n  private convertFirestoreToBudget(doc: DocumentData): Budget {\r\n    const data = doc.data();\r\n    return {\r\n      id: doc.id,\r\n      userId: data.userId,\r\n      category: data.category,\r\n      amount: data.amount,\r\n      period: data.period,\r\n      startDate: this.convertTimestamp(data.startDate),\r\n      endDate: this.convertTimestamp(data.endDate),\r\n      spent: data.spent || 0,\r\n      remaining: data.remaining || data.amount,\r\n      alerts: data.alerts || [],\r\n      isActive: data.isActive !== false,\r\n      createdAt: this.convertTimestamp(data.createdAt || serverTimestamp()),\r\n      updatedAt: this.convertTimestamp(data.updatedAt || serverTimestamp()),\r\n    };\r\n  }\r\n\r\n  async createBudget(budgetData: Omit<Budget, 'id' | 'userId' | 'createdAt' | 'updatedAt'>): Promise<Budget> {\r\n    try {\r\n      const budgetsRef = this.getUserBudgetsCollection();\r\n      const budgetDoc = {\r\n        ...budgetData,\r\n        userId: this.userId,\r\n        createdAt: serverTimestamp(),\r\n        updatedAt: serverTimestamp(),\r\n      };\r\n      \r\n      const docRef = await addDoc(budgetsRef, budgetDoc);\r\n      const budgetSnap = await getDoc(docRef);\r\n      \r\n      if (budgetSnap.exists()) {\r\n        return this.convertFirestoreToBudget(budgetSnap);\r\n      }\r\n      \r\n      throw new Error('Failed to create budget');\r\n    } catch (error) {\r\n      console.error('Error creating budget:', error);\r\n      throw new Error('Failed to create budget');\r\n    }\r\n  }\r\n\r\n  async getBudgets(userId: string): Promise<Budget[]> {\r\n    try {\r\n      const budgetsRef = this.getUserBudgetsCollection();\r\n      const querySnapshot = await getDocs(budgetsRef);\r\n      \r\n      return querySnapshot.docs.map(doc => this.convertFirestoreToBudget(doc));\r\n    } catch (error) {\r\n      console.error('Error fetching budgets:', error);\r\n      throw new Error('Failed to fetch budgets');\r\n    }\r\n  }\r\n\r\n  async getBudget(id: string): Promise<Budget | null> {\r\n    try {\r\n      const budgetRef = this.getBudgetDocRef(id);\r\n      const budgetSnap = await getDoc(budgetRef);\r\n      \r\n      if (budgetSnap.exists()) {\r\n        return this.convertFirestoreToBudget(budgetSnap);\r\n      }\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error fetching budget:', error);\r\n      throw new Error('Failed to fetch budget');\r\n    }\r\n  }\r\n\r\n  async updateBudget(id: string, updates: Partial<Budget>): Promise<Budget> {\r\n    try {\r\n      const budgetRef = this.getBudgetDocRef(id);\r\n      const updatedBudget = {\r\n        ...updates,\r\n        updatedAt: serverTimestamp(),\r\n      };\r\n      \r\n      await updateDoc(budgetRef, updatedBudget);\r\n      \r\n      // Fetch updated budget\r\n      const budgetSnap = await getDoc(budgetRef);\r\n      if (budgetSnap.exists()) {\r\n        return this.convertFirestoreToBudget(budgetSnap);\r\n      }\r\n      \r\n      throw new Error('Budget not found');\r\n    } catch (error) {\r\n      console.error('Error updating budget:', error);\r\n      throw new Error('Failed to update budget');\r\n    }\r\n  }\r\n\r\n  async deleteBudget(id: string): Promise<boolean> {\r\n    try {\r\n      const budgetRef = this.getBudgetDocRef(id);\r\n      await deleteDoc(budgetRef);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting budget:', error);\r\n      throw new Error('Failed to delete budget');\r\n    }\r\n  }\r\n\r\n  async getBudgetProgress(budgetId: string): Promise<BudgetProgress> {\r\n    try {\r\n      const budget = await this.getBudget(budgetId);\r\n      if (!budget) {\r\n        throw new Error('Budget not found');\r\n      }\r\n      \r\n      const percentageUsed = (budget.spent / budget.amount) * 100;\r\n      const isOverBudget = budget.spent > budget.amount;\r\n      const daysRemaining = Math.ceil((new Date(budget.endDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24));\r\n      const projectedSpending = budget.spent + (budget.spent / (30 - daysRemaining)) * daysRemaining;\r\n      \r\n      return {\r\n        budgetId,\r\n        spent: budget.spent,\r\n        remaining: budget.remaining,\r\n        percentageUsed,\r\n        isOverBudget,\r\n        daysRemaining: Math.max(0, daysRemaining),\r\n        projectedSpending,\r\n      };\r\n    } catch (error) {\r\n      console.error('Error calculating budget progress:', error);\r\n      throw new Error('Failed to calculate budget progress');\r\n    }\r\n  }\r\n\r\n  async getBudgetSummary(userId: string): Promise<BudgetSummary> {\r\n    try {\r\n      const budgets = await this.getBudgets(userId);\r\n      const activeBudgets = budgets.filter(budget => budget.isActive);\r\n      \r\n      const totalBudgeted = activeBudgets.reduce((sum, budget) => sum + budget.amount, 0);\r\n      const totalSpent = activeBudgets.reduce((sum, budget) => sum + budget.spent, 0);\r\n      const totalRemaining = totalBudgeted - totalSpent;\r\n      const overBudgetCategories = activeBudgets\r\n        .filter(budget => budget.spent > budget.amount)\r\n        .map(budget => budget.category);\r\n      \r\n      const upcomingAlerts = activeBudgets.flatMap(budget => \r\n        budget.alerts.filter(alert => !alert.triggered)\r\n      );\r\n      \r\n      return {\r\n        totalBudgets: activeBudgets.length,\r\n        totalBudgeted,\r\n        totalSpent,\r\n        totalRemaining,\r\n        overBudgetCategories,\r\n        upcomingAlerts,\r\n      };\r\n    } catch (error) {\r\n      console.error('Error calculating budget summary:', error);\r\n      throw new Error('Failed to calculate budget summary');\r\n    }\r\n  }\r\n\r\n  async calculateBudgetSpending(budgetId: string, transactions: any[]): Promise<number> {\r\n    try {\r\n      const budget = await this.getBudget(budgetId);\r\n      if (!budget) {\r\n        return 0;\r\n      }\r\n      \r\n      // Filter transactions by category and date range\r\n      const relevantTransactions = transactions.filter(tx => \r\n        tx.category === budget.category &&\r\n        new Date(tx.date) >= new Date(budget.startDate) &&\r\n        new Date(tx.date) <= new Date(budget.endDate) &&\r\n        tx.amount < 0 // Only expenses\r\n      );\r\n      \r\n      return Math.abs(relevantTransactions.reduce((sum, tx) => sum + tx.amount, 0));\r\n    } catch (error) {\r\n      console.error('Error calculating budget spending:', error);\r\n      throw new Error('Failed to calculate budget spending');\r\n    }\r\n  }\r\n\r\n  async createBudgetAlert(budgetId: string, alertData: Omit<BudgetAlert, 'id' | 'createdAt'>): Promise<BudgetAlert> {\r\n    try {\r\n      const budget = await this.getBudget(budgetId);\r\n      if (!budget) {\r\n        throw new Error('Budget not found');\r\n      }\r\n      \r\n      const alert: BudgetAlert = {\r\n        ...alertData,\r\n        id: `alert-${Date.now()}`,\r\n        createdAt: new Date().toISOString(),\r\n      };\r\n      \r\n      // Add alert to budget\r\n      const updatedAlerts = [...budget.alerts, alert];\r\n      await this.updateBudget(budgetId, { alerts: updatedAlerts });\r\n      \r\n      return alert;\r\n    } catch (error) {\r\n      console.error('Error creating budget alert:', error);\r\n      throw new Error('Failed to create budget alert');\r\n    }\r\n  }\r\n\r\n  async getBudgetAlerts(budgetId: string): Promise<BudgetAlert[]> {\r\n    try {\r\n      const budget = await this.getBudget(budgetId);\r\n      return budget?.alerts || [];\r\n    } catch (error) {\r\n      console.error('Error fetching budget alerts:', error);\r\n      throw new Error('Failed to fetch budget alerts');\r\n    }\r\n  }\r\n\r\n  async updateBudgetAlert(alertId: string, updates: Partial<BudgetAlert>): Promise<BudgetAlert> {\r\n    try {\r\n      // Find budget containing this alert\r\n      const budgets = await this.getBudgets(this.userId);\r\n      const budgetWithAlert = budgets.find(budget => \r\n        budget.alerts.some(alert => alert.id === alertId)\r\n      );\r\n      \r\n      if (!budgetWithAlert) {\r\n        throw new Error('Alert not found');\r\n      }\r\n      \r\n      // Update the alert\r\n      const updatedAlerts = budgetWithAlert.alerts.map(alert => \r\n        alert.id === alertId ? { ...alert, ...updates } : alert\r\n      );\r\n      \r\n      await this.updateBudget(budgetWithAlert.id, { alerts: updatedAlerts });\r\n      \r\n      const updatedAlert = updatedAlerts.find(alert => alert.id === alertId);\r\n      if (!updatedAlert) {\r\n        throw new Error('Failed to update alert');\r\n      }\r\n      \r\n      return updatedAlert;\r\n    } catch (error) {\r\n      console.error('Error updating budget alert:', error);\r\n      throw new Error('Failed to update budget alert');\r\n    }\r\n  }\r\n\r\n  subscribeToBudgets(userId: string, callback: (budgets: Budget[]) => void): () => void {\r\n    const budgetsRef = this.getUserBudgetsCollection();\r\n    return onSnapshot(budgetsRef, (snapshot) => {\r\n      const budgets = snapshot.docs.map(doc => this.convertFirestoreToBudget(doc));\r\n      callback(budgets);\r\n    });\r\n  }\r\n\r\n  subscribeToBudgetProgress(budgetId: string, callback: (progress: BudgetProgress) => void): () => void {\r\n    const budgetRef = this.getBudgetDocRef(budgetId);\r\n    return onSnapshot(budgetRef, async (snapshot: any) => {\r\n      if (snapshot.exists()) {\r\n        const progress = await this.getBudgetProgress(budgetId);\r\n        callback(progress);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport function createBudgetService(config: BudgetServiceConfig, userId?: string): BudgetService {\r\n  if (config.useMockData) {\r\n    return new MockBudgetService();\r\n  } else {\r\n    if (!userId) {\r\n      throw new Error('User ID is required for Firebase BudgetService');\r\n    }\r\n    return new FirebaseBudgetService(config, userId);\r\n  }\r\n}\r\n\r\n// Export classes for testing\r\nexport { MockBudgetService, FirebaseBudgetService };\r\n\r\n// Default export for convenience\r\nexport default createBudgetService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}