{"ast":null,"code":"import { MOCK_ACCOUNTS } from '../constants/financial';\nimport { calculateFinancialSummary } from '../utils/periodCalculations';\nimport { getDocs, getDoc, setDoc, deleteDoc, query, where, orderBy, onSnapshot, serverTimestamp, Timestamp } from 'firebase/firestore';\nimport { getUserAccountsCollection, getUserTransactionsCollection, getAccountDocRef, getTransactionDocRef } from '../config/firebase';\nclass MockDataService {\n  constructor() {\n    this.accounts = MOCK_ACCOUNTS;\n    this.transactions = [];\n    // Generate mock transactions for all accounts\n    this.generateMockTransactions();\n  }\n  generateMockTransactions() {\n    this.transactions = [];\n    this.accounts.forEach(account => {\n      // Generate 20-50 transactions per account\n      const transactionCount = Math.floor(Math.random() * 30) + 20;\n      for (let i = 0; i < transactionCount; i++) {\n        const date = new Date();\n        date.setDate(date.getDate() - Math.floor(Math.random() * 90)); // Random date within last 90 days\n\n        const amount = Math.random() > 0.6 ? -(Math.random() * 500 + 10) :\n        // 40% chance of expense\n        Math.random() * 2000 + 100; // 60% chance of income\n\n        this.transactions.push({\n          id: `${account.id}-tx-${i}`,\n          accountId: account.id,\n          amount,\n          date: date.toISOString(),\n          description: this.generateMockDescription(amount),\n          category: this.generateMockCategory(amount),\n          tags: this.generateMockTags(amount),\n          pending: false,\n          cleanMerchant: {\n            cleanName: this.generateMockMerchant(amount),\n            logo: '',\n            suggestedCategory: this.generateMockCategory(amount),\n            original: this.generateMockMerchant(amount)\n          },\n          createdAt: date.toISOString(),\n          updatedAt: date.toISOString()\n        });\n      }\n    });\n  }\n  generateMockDescription(amount) {\n    const descriptions = amount > 0 ? ['Salary Deposit', 'Freelance Payment', 'Investment Dividend', 'Refund', 'Bonus Payment'] : ['Grocery Store', 'Gas Station', 'Restaurant', 'Online Purchase', 'Utility Bill', 'Subscription', 'Entertainment'];\n    return descriptions[Math.floor(Math.random() * descriptions.length)];\n  }\n  generateMockMerchant(amount) {\n    const merchants = amount > 0 ? ['Employer Corp', 'Freelance Platform', 'Investment Bank', 'Online Store'] : ['Walmart', 'Shell Gas', 'McDonald\\'s', 'Amazon', 'Netflix', 'Spotify', 'Electric Company'];\n    return merchants[Math.floor(Math.random() * merchants.length)];\n  }\n  generateMockCategory(amount) {\n    const categories = amount > 0 ? ['Income', 'Investment', 'Refund'] : ['Food & Dining', 'Transportation', 'Shopping', 'Entertainment', 'Utilities', 'Healthcare'];\n    return categories[Math.floor(Math.random() * categories.length)];\n  }\n  generateMockTags(amount) {\n    const tags = amount > 0 ? ['income', 'salary'] : ['expense', 'daily'];\n\n    // Add random tags\n    const allTags = ['groceries', 'transport', 'entertainment', 'utilities', 'shopping'];\n    const randomTag = allTags[Math.floor(Math.random() * allTags.length)];\n    if (Math.random() > 0.5) {\n      tags.push(randomTag);\n    }\n    return tags;\n  }\n  async getAccounts() {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n    return [...this.accounts];\n  }\n  async getAccount(id) {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    return this.accounts.find(account => account.id === id) || null;\n  }\n  async updateAccount(account) {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    const index = this.accounts.findIndex(a => a.id === account.id);\n    if (index !== -1) {\n      this.accounts[index] = account;\n    }\n    return account;\n  }\n  async deleteAccount(id) {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    const index = this.accounts.findIndex(account => account.id === id);\n    if (index !== -1) {\n      this.accounts.splice(index, 1);\n      // Remove associated transactions\n      this.transactions = this.transactions.filter(tx => tx.accountId !== id);\n      return true;\n    }\n    return false;\n  }\n  async getTransactions(accountId, filters) {\n    await new Promise(resolve => setTimeout(resolve, 150));\n    let filteredTransactions = [...this.transactions];\n    if (accountId) {\n      filteredTransactions = filteredTransactions.filter(tx => tx.accountId === accountId);\n    }\n\n    // Apply filters if provided\n    if (filters) {\n      if (filters.category) {\n        filteredTransactions = filteredTransactions.filter(tx => tx.category === filters.category);\n      }\n      if (filters.type) {\n        const isIncome = filters.type === 'income';\n        filteredTransactions = filteredTransactions.filter(tx => tx.amount > 0 === isIncome);\n      }\n      if (filters.dateRange) {\n        const {\n          startDate,\n          endDate\n        } = filters.dateRange;\n        filteredTransactions = filteredTransactions.filter(tx => {\n          const txDate = new Date(tx.date);\n          return txDate >= startDate && txDate <= endDate;\n        });\n      }\n    }\n    return filteredTransactions;\n  }\n  async getTransaction(id) {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    return this.transactions.find(transaction => transaction.id === id) || null;\n  }\n  async updateTransaction(transaction) {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    const index = this.transactions.findIndex(tx => tx.id === transaction.id);\n    if (index !== -1) {\n      this.transactions[index] = transaction;\n    }\n    return transaction;\n  }\n  async deleteTransaction(id) {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    const index = this.transactions.findIndex(transaction => transaction.id === id);\n    if (index !== -1) {\n      this.transactions.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n  async getFinancialSummary(period, customDateRange, accountFilter) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    let filteredTransactions = [...this.transactions];\n\n    // Filter by account type if specified\n    if (accountFilter && accountFilter !== 'both') {\n      const filteredAccounts = this.accounts.filter(account => {\n        if (accountFilter === 'personal') return !account.type.includes('BUSINESS');\n        if (accountFilter === 'business') return account.type.includes('BUSINESS');\n        return true;\n      });\n      const accountIds = filteredAccounts.map(account => account.id);\n      filteredTransactions = filteredTransactions.filter(tx => accountIds.includes(tx.accountId));\n    }\n    const totalBalance = this.accounts.reduce((sum, account) => sum + account.balance, 0);\n    return calculateFinancialSummary(filteredTransactions, period, customDateRange, totalBalance);\n  }\n  async searchTransactions(query) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    const lowerQuery = query.toLowerCase();\n    return this.transactions.filter(transaction => transaction.description.toLowerCase().includes(lowerQuery) || transaction.cleanMerchant.cleanName.toLowerCase().includes(lowerQuery) || transaction.category.toLowerCase().includes(lowerQuery) || transaction.tags.some(tag => tag.toLowerCase().includes(lowerQuery)));\n  }\n  async getTransactionStats(accountId) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    let filteredTransactions = [...this.transactions];\n    if (accountId) {\n      filteredTransactions = filteredTransactions.filter(tx => tx.accountId === accountId);\n    }\n    const totalIncome = filteredTransactions.filter(tx => tx.amount > 0).reduce((sum, tx) => sum + tx.amount, 0);\n    const totalExpenses = filteredTransactions.filter(tx => tx.amount < 0).reduce((sum, tx) => sum + Math.abs(tx.amount), 0);\n    const categoryStats = filteredTransactions.reduce((stats, tx) => {\n      const category = tx.category;\n      if (!stats[category]) {\n        stats[category] = {\n          count: 0,\n          total: 0\n        };\n      }\n      stats[category].count++;\n      stats[category].total += Math.abs(tx.amount);\n      return stats;\n    }, {});\n    return {\n      totalTransactions: filteredTransactions.length,\n      totalIncome,\n      totalExpenses,\n      netAmount: totalIncome - totalExpenses,\n      categoryStats,\n      averageTransactionAmount: filteredTransactions.length > 0 ? filteredTransactions.reduce((sum, tx) => sum + Math.abs(tx.amount), 0) / filteredTransactions.length : 0\n    };\n  }\n}\nclass FirebaseDataService {\n  constructor(config, userId) {\n    this.config = void 0;\n    this.userId = void 0;\n    this.config = config;\n    this.userId = userId;\n  }\n\n  // Helper method to convert Firestore timestamp to ISO string\n  convertTimestamp(timestamp) {\n    if (typeof timestamp === 'string') return timestamp;\n    return timestamp.toDate().toISOString();\n  }\n\n  // Helper method to convert ISO string to Firestore timestamp\n  convertToTimestamp(dateString) {\n    return Timestamp.fromDate(new Date(dateString));\n  }\n\n  // Helper method to convert Firestore document to Account\n  convertFirestoreToAccount(doc) {\n    const data = doc.data();\n    return {\n      id: doc.id,\n      name: data.name,\n      type: data.type,\n      balance: data.balance || 0,\n      accountNumber: data.accountNumber || '',\n      bankName: data.bankName || '',\n      limit: data.limit,\n      isActive: data.isActive !== false,\n      createdAt: this.convertTimestamp(data.createdAt || serverTimestamp()),\n      updatedAt: this.convertTimestamp(data.updatedAt || serverTimestamp())\n    };\n  }\n\n  // Helper method to convert Firestore document to Transaction\n  convertFirestoreToTransaction(doc) {\n    const data = doc.data();\n    return {\n      id: doc.id,\n      accountId: data.accountId,\n      description: data.description,\n      amount: data.amount,\n      date: this.convertTimestamp(data.date),\n      category: data.category,\n      tags: data.tags || [],\n      pending: data.pending || false,\n      cleanMerchant: data.cleanMerchant || {\n        cleanName: data.merchant || '',\n        logo: '',\n        suggestedCategory: data.category || '',\n        original: data.merchant || ''\n      },\n      notes: data.notes,\n      receiptUrl: data.receiptUrl,\n      createdAt: this.convertTimestamp(data.createdAt || serverTimestamp()),\n      updatedAt: this.convertTimestamp(data.updatedAt || serverTimestamp())\n    };\n  }\n  async getAccounts() {\n    try {\n      const accountsRef = getUserAccountsCollection(this.userId);\n      const querySnapshot = await getDocs(accountsRef);\n      return querySnapshot.docs.map(doc => this.convertFirestoreToAccount(doc));\n    } catch (error) {\n      console.error('Error fetching accounts:', error);\n      throw new Error('Failed to fetch accounts');\n    }\n  }\n  async getAccount(id) {\n    try {\n      const accountRef = getAccountDocRef(this.userId, id);\n      const accountSnap = await getDoc(accountRef);\n      if (accountSnap.exists()) {\n        return this.convertFirestoreToAccount(accountSnap);\n      }\n      return null;\n    } catch (error) {\n      console.error('Error fetching account:', error);\n      throw new Error('Failed to fetch account');\n    }\n  }\n  async updateAccount(account) {\n    try {\n      const accountRef = getAccountDocRef(this.userId, account.id);\n      const updatedAccount = {\n        ...account,\n        updatedAt: serverTimestamp()\n      };\n      await setDoc(accountRef, updatedAccount);\n      return account;\n    } catch (error) {\n      console.error('Error updating account:', error);\n      throw new Error('Failed to update account');\n    }\n  }\n  async deleteAccount(id) {\n    try {\n      const accountRef = getAccountDocRef(this.userId, id);\n      await deleteDoc(accountRef);\n\n      // Also delete associated transactions\n      const transactionsRef = getUserTransactionsCollection(this.userId);\n      const transactionsQuery = query(transactionsRef, where('accountId', '==', id));\n      const transactionsSnap = await getDocs(transactionsQuery);\n      const deletePromises = transactionsSnap.docs.map(doc => deleteDoc(doc.ref));\n      await Promise.all(deletePromises);\n      return true;\n    } catch (error) {\n      console.error('Error deleting account:', error);\n      throw new Error('Failed to delete account');\n    }\n  }\n  async getTransactions(accountId, filters) {\n    try {\n      const transactionsRef = getUserTransactionsCollection(this.userId);\n      const constraints = [orderBy('date', 'desc')];\n      if (accountId) {\n        constraints.push(where('accountId', '==', accountId));\n      }\n\n      // Apply filters\n      if (filters) {\n        if (filters.category) {\n          constraints.push(where('category', '==', filters.category));\n        }\n        if (filters.type) {\n          const isIncome = filters.type === 'income';\n          constraints.push(where('amount', isIncome ? '>' : '<', 0));\n        }\n        if (filters.dateRange) {\n          constraints.push(where('date', '>=', this.convertToTimestamp(filters.dateRange.startDate)), where('date', '<=', this.convertToTimestamp(filters.dateRange.endDate)));\n        }\n      }\n      const transactionsQuery = query(transactionsRef, ...constraints);\n      const querySnapshot = await getDocs(transactionsQuery);\n      return querySnapshot.docs.map(doc => this.convertFirestoreToTransaction(doc));\n    } catch (error) {\n      console.error('Error fetching transactions:', error);\n      throw new Error('Failed to fetch transactions');\n    }\n  }\n  async getTransaction(id) {\n    try {\n      const transactionRef = getTransactionDocRef(this.userId, id);\n      const transactionSnap = await getDoc(transactionRef);\n      if (transactionSnap.exists()) {\n        return this.convertFirestoreToTransaction(transactionSnap);\n      }\n      return null;\n    } catch (error) {\n      console.error('Error fetching transaction:', error);\n      throw new Error('Failed to fetch transaction');\n    }\n  }\n  async updateTransaction(transaction) {\n    try {\n      const transactionRef = getTransactionDocRef(this.userId, transaction.id);\n      const updatedTransaction = {\n        ...transaction,\n        updatedAt: serverTimestamp()\n      };\n      await setDoc(transactionRef, updatedTransaction);\n      return transaction;\n    } catch (error) {\n      console.error('Error updating transaction:', error);\n      throw new Error('Failed to update transaction');\n    }\n  }\n  async deleteTransaction(id) {\n    try {\n      const transactionRef = getTransactionDocRef(this.userId, id);\n      await deleteDoc(transactionRef);\n      return true;\n    } catch (error) {\n      console.error('Error deleting transaction:', error);\n      throw new Error('Failed to delete transaction');\n    }\n  }\n  async getFinancialSummary(period, customDateRange, accountFilter) {\n    try {\n      // Get all transactions for the period\n      const transactions = await this.getTransactions();\n\n      // Filter by account type if specified\n      let filteredTransactions = transactions;\n      if (accountFilter && accountFilter !== 'both') {\n        const accounts = await this.getAccounts();\n        const filteredAccounts = accounts.filter(account => {\n          if (accountFilter === 'personal') return !account.type.includes('BUSINESS');\n          if (accountFilter === 'business') return account.type.includes('BUSINESS');\n          return true;\n        });\n        const accountIds = filteredAccounts.map(account => account.id);\n        filteredTransactions = transactions.filter(tx => accountIds.includes(tx.accountId));\n      }\n      const totalBalance = (await this.getAccounts()).reduce((sum, account) => sum + account.balance, 0);\n      return calculateFinancialSummary(filteredTransactions, period, customDateRange, totalBalance);\n    } catch (error) {\n      console.error('Error calculating financial summary:', error);\n      throw new Error('Failed to calculate financial summary');\n    }\n  }\n  async searchTransactions(query) {\n    try {\n      // Firestore doesn't support full-text search, so we'll fetch all transactions and filter client-side\n      // In production, you might want to use Algolia or similar for better search\n      const transactions = await this.getTransactions();\n      const lowerQuery = query.toLowerCase();\n      return transactions.filter(transaction => transaction.description.toLowerCase().includes(lowerQuery) || transaction.cleanMerchant.cleanName.toLowerCase().includes(lowerQuery) || transaction.category.toLowerCase().includes(lowerQuery) || transaction.tags.some(tag => tag.toLowerCase().includes(lowerQuery)));\n    } catch (error) {\n      console.error('Error searching transactions:', error);\n      throw new Error('Failed to search transactions');\n    }\n  }\n  async getTransactionStats(accountId) {\n    try {\n      const transactions = await this.getTransactions(accountId);\n      const totalIncome = transactions.filter(tx => tx.amount > 0).reduce((sum, tx) => sum + tx.amount, 0);\n      const totalExpenses = transactions.filter(tx => tx.amount < 0).reduce((sum, tx) => sum + Math.abs(tx.amount), 0);\n      const categoryStats = transactions.reduce((stats, tx) => {\n        const category = tx.category;\n        if (!stats[category]) {\n          stats[category] = {\n            count: 0,\n            total: 0\n          };\n        }\n        stats[category].count++;\n        stats[category].total += Math.abs(tx.amount);\n        return stats;\n      }, {});\n      return {\n        totalTransactions: transactions.length,\n        totalIncome,\n        totalExpenses,\n        netAmount: totalIncome - totalExpenses,\n        categoryStats,\n        averageTransactionAmount: transactions.length > 0 ? transactions.reduce((sum, tx) => sum + Math.abs(tx.amount), 0) / transactions.length : 0\n      };\n    } catch (error) {\n      console.error('Error calculating transaction stats:', error);\n      throw new Error('Failed to calculate transaction stats');\n    }\n  }\n\n  // Real-time listeners for live data synchronization\n  subscribeToAccounts(callback) {\n    const accountsRef = getUserAccountsCollection(this.userId);\n    return onSnapshot(accountsRef, snapshot => {\n      const accounts = snapshot.docs.map(doc => this.convertFirestoreToAccount(doc));\n      callback(accounts);\n    });\n  }\n  subscribeToTransactions(callback, accountId) {\n    const transactionsRef = getUserTransactionsCollection(this.userId);\n    const constraints = [orderBy('date', 'desc')];\n    if (accountId) {\n      constraints.push(where('accountId', '==', accountId));\n    }\n    const transactionsQuery = query(transactionsRef, ...constraints);\n    return onSnapshot(transactionsQuery, snapshot => {\n      const transactions = snapshot.docs.map(doc => this.convertFirestoreToTransaction(doc));\n      callback(transactions);\n    });\n  }\n}\nexport function createDataService(config, userId) {\n  if (config.useMockData) {\n    return new MockDataService();\n  } else {\n    if (!userId) {\n      throw new Error('User ID is required for Firebase DataService');\n    }\n    return new FirebaseDataService(config, userId);\n  }\n}\n\n// Export classes for testing\nexport { MockDataService, FirebaseDataService };\n\n// Default export for convenience\nexport default createDataService;","map":{"version":3,"names":["MOCK_ACCOUNTS","calculateFinancialSummary","getDocs","getDoc","setDoc","deleteDoc","query","where","orderBy","onSnapshot","serverTimestamp","Timestamp","getUserAccountsCollection","getUserTransactionsCollection","getAccountDocRef","getTransactionDocRef","MockDataService","constructor","accounts","transactions","generateMockTransactions","forEach","account","transactionCount","Math","floor","random","i","date","Date","setDate","getDate","amount","push","id","accountId","toISOString","description","generateMockDescription","category","generateMockCategory","tags","generateMockTags","pending","cleanMerchant","cleanName","generateMockMerchant","logo","suggestedCategory","original","createdAt","updatedAt","descriptions","length","merchants","categories","allTags","randomTag","getAccounts","Promise","resolve","setTimeout","getAccount","find","updateAccount","index","findIndex","a","deleteAccount","splice","filter","tx","getTransactions","filters","filteredTransactions","type","isIncome","dateRange","startDate","endDate","txDate","getTransaction","transaction","updateTransaction","deleteTransaction","getFinancialSummary","period","customDateRange","accountFilter","filteredAccounts","includes","accountIds","map","totalBalance","reduce","sum","balance","searchTransactions","lowerQuery","toLowerCase","some","tag","getTransactionStats","totalIncome","totalExpenses","abs","categoryStats","stats","count","total","totalTransactions","netAmount","averageTransactionAmount","FirebaseDataService","config","userId","convertTimestamp","timestamp","toDate","convertToTimestamp","dateString","fromDate","convertFirestoreToAccount","doc","data","name","accountNumber","bankName","limit","isActive","convertFirestoreToTransaction","merchant","notes","receiptUrl","accountsRef","querySnapshot","docs","error","console","Error","accountRef","accountSnap","exists","updatedAccount","transactionsRef","transactionsQuery","transactionsSnap","deletePromises","ref","all","constraints","transactionRef","transactionSnap","updatedTransaction","subscribeToAccounts","callback","snapshot","subscribeToTransactions","createDataService","useMockData"],"sources":["C:/Users/X2DHHWAN/Desktop/Finance-App/src/services/DataService.ts"],"sourcesContent":["import { Account, Transaction, FinancialSummary, TimePeriod, CustomDateRange } from '../types/financial';\r\nimport { MOCK_ACCOUNTS } from '../constants/financial';\r\nimport { calculateFinancialSummary } from '../utils/periodCalculations';\r\nimport { \r\n  getDocs, \r\n  getDoc, \r\n  setDoc, \r\n  updateDoc, \r\n  deleteDoc, \r\n  query, \r\n  where, \r\n  orderBy, \r\n  limit, \r\n  onSnapshot,\r\n  addDoc,\r\n  serverTimestamp,\r\n  Timestamp,\r\n  QueryConstraint,\r\n  DocumentData\r\n} from 'firebase/firestore';\r\nimport { \r\n  db, \r\n  getUserAccountsCollection, \r\n  getUserTransactionsCollection, \r\n  getAccountDocRef, \r\n  getTransactionDocRef \r\n} from '../config/firebase';\r\n\r\nexport interface DataServiceConfig {\r\n  useMockData: boolean;\r\n  apiBaseUrl?: string;\r\n  apiKey?: string;\r\n}\r\n\r\nexport interface DataServiceResponse<T> {\r\n  data: T;\r\n  error?: string;\r\n  loading: boolean;\r\n}\r\n\r\nexport interface DataService {\r\n  // Account operations\r\n  getAccounts(): Promise<Account[]>;\r\n  getAccount(id: string): Promise<Account | null>;\r\n  updateAccount(account: Account): Promise<Account>;\r\n  deleteAccount(id: string): Promise<boolean>;\r\n  \r\n  // Transaction operations\r\n  getTransactions(accountId?: string, filters?: any): Promise<Transaction[]>;\r\n  getTransaction(id: string): Promise<Transaction | null>;\r\n  updateTransaction(transaction: Transaction): Promise<Transaction>;\r\n  deleteTransaction(id: string): Promise<boolean>;\r\n  \r\n  // Financial summary operations\r\n  getFinancialSummary(\r\n    period: TimePeriod,\r\n    customDateRange?: CustomDateRange,\r\n    accountFilter?: string\r\n  ): Promise<FinancialSummary>;\r\n  \r\n  // Utility operations\r\n  searchTransactions(query: string): Promise<Transaction[]>;\r\n  getTransactionStats(accountId?: string): Promise<any>;\r\n}\r\n\r\nclass MockDataService implements DataService {\r\n  private accounts: Account[] = MOCK_ACCOUNTS;\r\n  private transactions: Transaction[] = [];\r\n\r\n  constructor() {\r\n    // Generate mock transactions for all accounts\r\n    this.generateMockTransactions();\r\n  }\r\n\r\n  private generateMockTransactions(): void {\r\n    this.transactions = [];\r\n    this.accounts.forEach(account => {\r\n      // Generate 20-50 transactions per account\r\n      const transactionCount = Math.floor(Math.random() * 30) + 20;\r\n      \r\n      for (let i = 0; i < transactionCount; i++) {\r\n        const date = new Date();\r\n        date.setDate(date.getDate() - Math.floor(Math.random() * 90)); // Random date within last 90 days\r\n        \r\n        const amount = Math.random() > 0.6 ? \r\n          -(Math.random() * 500 + 10) : // 40% chance of expense\r\n          (Math.random() * 2000 + 100); // 60% chance of income\r\n        \r\n        this.transactions.push({\r\n          id: `${account.id}-tx-${i}`,\r\n          accountId: account.id,\r\n          amount,\r\n          date: date.toISOString(),\r\n          description: this.generateMockDescription(amount),\r\n          category: this.generateMockCategory(amount),\r\n          tags: this.generateMockTags(amount),\r\n          pending: false,\r\n          cleanMerchant: {\r\n            cleanName: this.generateMockMerchant(amount),\r\n            logo: '',\r\n            suggestedCategory: this.generateMockCategory(amount),\r\n            original: this.generateMockMerchant(amount),\r\n          },\r\n          createdAt: date.toISOString(),\r\n          updatedAt: date.toISOString(),\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  private generateMockDescription(amount: number): string {\r\n    const descriptions = amount > 0 ? [\r\n      'Salary Deposit',\r\n      'Freelance Payment',\r\n      'Investment Dividend',\r\n      'Refund',\r\n      'Bonus Payment'\r\n    ] : [\r\n      'Grocery Store',\r\n      'Gas Station',\r\n      'Restaurant',\r\n      'Online Purchase',\r\n      'Utility Bill',\r\n      'Subscription',\r\n      'Entertainment'\r\n    ];\r\n    \r\n    return descriptions[Math.floor(Math.random() * descriptions.length)];\r\n  }\r\n\r\n  private generateMockMerchant(amount: number): string {\r\n    const merchants = amount > 0 ? [\r\n      'Employer Corp',\r\n      'Freelance Platform',\r\n      'Investment Bank',\r\n      'Online Store'\r\n    ] : [\r\n      'Walmart',\r\n      'Shell Gas',\r\n      'McDonald\\'s',\r\n      'Amazon',\r\n      'Netflix',\r\n      'Spotify',\r\n      'Electric Company'\r\n    ];\r\n    \r\n    return merchants[Math.floor(Math.random() * merchants.length)];\r\n  }\r\n\r\n  private generateMockCategory(amount: number): string {\r\n    const categories = amount > 0 ? [\r\n      'Income',\r\n      'Investment',\r\n      'Refund'\r\n    ] : [\r\n      'Food & Dining',\r\n      'Transportation',\r\n      'Shopping',\r\n      'Entertainment',\r\n      'Utilities',\r\n      'Healthcare'\r\n    ];\r\n    \r\n    return categories[Math.floor(Math.random() * categories.length)];\r\n  }\r\n\r\n  private generateMockTags(amount: number): string[] {\r\n    const tags = amount > 0 ? ['income', 'salary'] : ['expense', 'daily'];\r\n    \r\n    // Add random tags\r\n    const allTags = ['groceries', 'transport', 'entertainment', 'utilities', 'shopping'];\r\n    const randomTag = allTags[Math.floor(Math.random() * allTags.length)];\r\n    if (Math.random() > 0.5) {\r\n      tags.push(randomTag);\r\n    }\r\n    \r\n    return tags;\r\n  }\r\n\r\n  async getAccounts(): Promise<Account[]> {\r\n    // Simulate API delay\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    return [...this.accounts];\r\n  }\r\n\r\n  async getAccount(id: string): Promise<Account | null> {\r\n    await new Promise(resolve => setTimeout(resolve, 50));\r\n    return this.accounts.find(account => account.id === id) || null;\r\n  }\r\n\r\n  async updateAccount(account: Account): Promise<Account> {\r\n    await new Promise(resolve => setTimeout(resolve, 200));\r\n    const index = this.accounts.findIndex(a => a.id === account.id);\r\n    if (index !== -1) {\r\n      this.accounts[index] = account;\r\n    }\r\n    return account;\r\n  }\r\n\r\n  async deleteAccount(id: string): Promise<boolean> {\r\n    await new Promise(resolve => setTimeout(resolve, 200));\r\n    const index = this.accounts.findIndex(account => account.id === id);\r\n    if (index !== -1) {\r\n      this.accounts.splice(index, 1);\r\n      // Remove associated transactions\r\n      this.transactions = this.transactions.filter(tx => tx.accountId !== id);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async getTransactions(accountId?: string, filters?: any): Promise<Transaction[]> {\r\n    await new Promise(resolve => setTimeout(resolve, 150));\r\n    let filteredTransactions = [...this.transactions];\r\n    \r\n    if (accountId) {\r\n      filteredTransactions = filteredTransactions.filter(tx => tx.accountId === accountId);\r\n    }\r\n    \r\n    // Apply filters if provided\r\n    if (filters) {\r\n      if (filters.category) {\r\n        filteredTransactions = filteredTransactions.filter(tx => tx.category === filters.category);\r\n      }\r\n      if (filters.type) {\r\n        const isIncome = filters.type === 'income';\r\n        filteredTransactions = filteredTransactions.filter(tx => (tx.amount > 0) === isIncome);\r\n      }\r\n      if (filters.dateRange) {\r\n        const { startDate, endDate } = filters.dateRange;\r\n        filteredTransactions = filteredTransactions.filter(tx => {\r\n          const txDate = new Date(tx.date);\r\n          return txDate >= startDate && txDate <= endDate;\r\n        });\r\n      }\r\n    }\r\n    \r\n    return filteredTransactions;\r\n  }\r\n\r\n  async getTransaction(id: string): Promise<Transaction | null> {\r\n    await new Promise(resolve => setTimeout(resolve, 50));\r\n    return this.transactions.find(transaction => transaction.id === id) || null;\r\n  }\r\n\r\n  async updateTransaction(transaction: Transaction): Promise<Transaction> {\r\n    await new Promise(resolve => setTimeout(resolve, 200));\r\n    const index = this.transactions.findIndex(tx => tx.id === transaction.id);\r\n    if (index !== -1) {\r\n      this.transactions[index] = transaction;\r\n    }\r\n    return transaction;\r\n  }\r\n\r\n  async deleteTransaction(id: string): Promise<boolean> {\r\n    await new Promise(resolve => setTimeout(resolve, 200));\r\n    const index = this.transactions.findIndex(transaction => transaction.id === id);\r\n    if (index !== -1) {\r\n      this.transactions.splice(index, 1);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async getFinancialSummary(\r\n    period: TimePeriod,\r\n    customDateRange?: CustomDateRange,\r\n    accountFilter?: string\r\n  ): Promise<FinancialSummary> {\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    \r\n    let filteredTransactions = [...this.transactions];\r\n    \r\n    // Filter by account type if specified\r\n    if (accountFilter && accountFilter !== 'both') {\r\n      const filteredAccounts = this.accounts.filter(account => {\r\n        if (accountFilter === 'personal') return !account.type.includes('BUSINESS');\r\n        if (accountFilter === 'business') return account.type.includes('BUSINESS');\r\n        return true;\r\n      });\r\n      const accountIds = filteredAccounts.map(account => account.id);\r\n      filteredTransactions = filteredTransactions.filter(tx => accountIds.includes(tx.accountId));\r\n    }\r\n    \r\n    const totalBalance = this.accounts.reduce((sum, account) => sum + account.balance, 0);\r\n    \r\n    return calculateFinancialSummary(filteredTransactions, period, customDateRange, totalBalance);\r\n  }\r\n\r\n  async searchTransactions(query: string): Promise<Transaction[]> {\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    const lowerQuery = query.toLowerCase();\r\n    \r\n    return this.transactions.filter(transaction => \r\n      transaction.description.toLowerCase().includes(lowerQuery) ||\r\n      transaction.cleanMerchant.cleanName.toLowerCase().includes(lowerQuery) ||\r\n      transaction.category.toLowerCase().includes(lowerQuery) ||\r\n      transaction.tags.some(tag => tag.toLowerCase().includes(lowerQuery))\r\n    );\r\n  }\r\n\r\n  async getTransactionStats(accountId?: string): Promise<any> {\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    \r\n    let filteredTransactions = [...this.transactions];\r\n    if (accountId) {\r\n      filteredTransactions = filteredTransactions.filter(tx => tx.accountId === accountId);\r\n    }\r\n    \r\n    const totalIncome = filteredTransactions\r\n      .filter(tx => tx.amount > 0)\r\n      .reduce((sum, tx) => sum + tx.amount, 0);\r\n    \r\n    const totalExpenses = filteredTransactions\r\n      .filter(tx => tx.amount < 0)\r\n      .reduce((sum, tx) => sum + Math.abs(tx.amount), 0);\r\n    \r\n    const categoryStats = filteredTransactions.reduce((stats, tx) => {\r\n      const category = tx.category;\r\n      if (!stats[category]) {\r\n        stats[category] = { count: 0, total: 0 };\r\n      }\r\n      stats[category].count++;\r\n      stats[category].total += Math.abs(tx.amount);\r\n      return stats;\r\n    }, {} as Record<string, { count: number; total: number }>);\r\n    \r\n    return {\r\n      totalTransactions: filteredTransactions.length,\r\n      totalIncome,\r\n      totalExpenses,\r\n      netAmount: totalIncome - totalExpenses,\r\n      categoryStats,\r\n      averageTransactionAmount: filteredTransactions.length > 0 \r\n        ? filteredTransactions.reduce((sum, tx) => sum + Math.abs(tx.amount), 0) / filteredTransactions.length \r\n        : 0\r\n    };\r\n  }\r\n}\r\n\r\nclass FirebaseDataService implements DataService {\r\n  private config: DataServiceConfig;\r\n  private userId: string;\r\n\r\n  constructor(config: DataServiceConfig, userId: string) {\r\n    this.config = config;\r\n    this.userId = userId;\r\n  }\r\n\r\n  // Helper method to convert Firestore timestamp to ISO string\r\n  private convertTimestamp(timestamp: Timestamp | string): string {\r\n    if (typeof timestamp === 'string') return timestamp;\r\n    return timestamp.toDate().toISOString();\r\n  }\r\n\r\n  // Helper method to convert ISO string to Firestore timestamp\r\n  private convertToTimestamp(dateString: string): Timestamp {\r\n    return Timestamp.fromDate(new Date(dateString));\r\n  }\r\n\r\n  // Helper method to convert Firestore document to Account\r\n  private convertFirestoreToAccount(doc: DocumentData): Account {\r\n    const data = doc.data();\r\n    return {\r\n      id: doc.id,\r\n      name: data.name,\r\n      type: data.type,\r\n      balance: data.balance || 0,\r\n      accountNumber: data.accountNumber || '',\r\n      bankName: data.bankName || '',\r\n      limit: data.limit,\r\n      isActive: data.isActive !== false,\r\n      createdAt: this.convertTimestamp(data.createdAt || serverTimestamp()),\r\n      updatedAt: this.convertTimestamp(data.updatedAt || serverTimestamp()),\r\n    };\r\n  }\r\n\r\n  // Helper method to convert Firestore document to Transaction\r\n  private convertFirestoreToTransaction(doc: DocumentData): Transaction {\r\n    const data = doc.data();\r\n    return {\r\n      id: doc.id,\r\n      accountId: data.accountId,\r\n      description: data.description,\r\n      amount: data.amount,\r\n      date: this.convertTimestamp(data.date),\r\n      category: data.category,\r\n      tags: data.tags || [],\r\n      pending: data.pending || false,\r\n      cleanMerchant: data.cleanMerchant || {\r\n        cleanName: data.merchant || '',\r\n        logo: '',\r\n        suggestedCategory: data.category || '',\r\n        original: data.merchant || '',\r\n      },\r\n      notes: data.notes,\r\n      receiptUrl: data.receiptUrl,\r\n      createdAt: this.convertTimestamp(data.createdAt || serverTimestamp()),\r\n      updatedAt: this.convertTimestamp(data.updatedAt || serverTimestamp()),\r\n    };\r\n  }\r\n\r\n  async getAccounts(): Promise<Account[]> {\r\n    try {\r\n      const accountsRef = getUserAccountsCollection(this.userId);\r\n      const querySnapshot = await getDocs(accountsRef);\r\n      \r\n      return querySnapshot.docs.map(doc => this.convertFirestoreToAccount(doc));\r\n    } catch (error) {\r\n      console.error('Error fetching accounts:', error);\r\n      throw new Error('Failed to fetch accounts');\r\n    }\r\n  }\r\n\r\n  async getAccount(id: string): Promise<Account | null> {\r\n    try {\r\n      const accountRef = getAccountDocRef(this.userId, id);\r\n      const accountSnap = await getDoc(accountRef);\r\n      \r\n      if (accountSnap.exists()) {\r\n        return this.convertFirestoreToAccount(accountSnap);\r\n      }\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error fetching account:', error);\r\n      throw new Error('Failed to fetch account');\r\n    }\r\n  }\r\n\r\n  async updateAccount(account: Account): Promise<Account> {\r\n    try {\r\n      const accountRef = getAccountDocRef(this.userId, account.id);\r\n      const updatedAccount = {\r\n        ...account,\r\n        updatedAt: serverTimestamp(),\r\n      };\r\n      \r\n      await setDoc(accountRef, updatedAccount);\r\n      return account;\r\n    } catch (error) {\r\n      console.error('Error updating account:', error);\r\n      throw new Error('Failed to update account');\r\n    }\r\n  }\r\n\r\n  async deleteAccount(id: string): Promise<boolean> {\r\n    try {\r\n      const accountRef = getAccountDocRef(this.userId, id);\r\n      await deleteDoc(accountRef);\r\n      \r\n      // Also delete associated transactions\r\n      const transactionsRef = getUserTransactionsCollection(this.userId);\r\n      const transactionsQuery = query(transactionsRef, where('accountId', '==', id));\r\n      const transactionsSnap = await getDocs(transactionsQuery);\r\n      \r\n      const deletePromises = transactionsSnap.docs.map(doc => deleteDoc(doc.ref));\r\n      await Promise.all(deletePromises);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting account:', error);\r\n      throw new Error('Failed to delete account');\r\n    }\r\n  }\r\n\r\n  async getTransactions(accountId?: string, filters?: any): Promise<Transaction[]> {\r\n    try {\r\n      const transactionsRef = getUserTransactionsCollection(this.userId);\r\n      const constraints: QueryConstraint[] = [orderBy('date', 'desc')];\r\n      \r\n      if (accountId) {\r\n        constraints.push(where('accountId', '==', accountId));\r\n      }\r\n      \r\n      // Apply filters\r\n      if (filters) {\r\n        if (filters.category) {\r\n          constraints.push(where('category', '==', filters.category));\r\n        }\r\n        if (filters.type) {\r\n          const isIncome = filters.type === 'income';\r\n          constraints.push(where('amount', isIncome ? '>' : '<', 0));\r\n        }\r\n        if (filters.dateRange) {\r\n          constraints.push(\r\n            where('date', '>=', this.convertToTimestamp(filters.dateRange.startDate)),\r\n            where('date', '<=', this.convertToTimestamp(filters.dateRange.endDate))\r\n          );\r\n        }\r\n      }\r\n      \r\n      const transactionsQuery = query(transactionsRef, ...constraints);\r\n      const querySnapshot = await getDocs(transactionsQuery);\r\n      \r\n      return querySnapshot.docs.map(doc => this.convertFirestoreToTransaction(doc));\r\n    } catch (error) {\r\n      console.error('Error fetching transactions:', error);\r\n      throw new Error('Failed to fetch transactions');\r\n    }\r\n  }\r\n\r\n  async getTransaction(id: string): Promise<Transaction | null> {\r\n    try {\r\n      const transactionRef = getTransactionDocRef(this.userId, id);\r\n      const transactionSnap = await getDoc(transactionRef);\r\n      \r\n      if (transactionSnap.exists()) {\r\n        return this.convertFirestoreToTransaction(transactionSnap);\r\n      }\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error fetching transaction:', error);\r\n      throw new Error('Failed to fetch transaction');\r\n    }\r\n  }\r\n\r\n  async updateTransaction(transaction: Transaction): Promise<Transaction> {\r\n    try {\r\n      const transactionRef = getTransactionDocRef(this.userId, transaction.id);\r\n      const updatedTransaction = {\r\n        ...transaction,\r\n        updatedAt: serverTimestamp(),\r\n      };\r\n      \r\n      await setDoc(transactionRef, updatedTransaction);\r\n      return transaction;\r\n    } catch (error) {\r\n      console.error('Error updating transaction:', error);\r\n      throw new Error('Failed to update transaction');\r\n    }\r\n  }\r\n\r\n  async deleteTransaction(id: string): Promise<boolean> {\r\n    try {\r\n      const transactionRef = getTransactionDocRef(this.userId, id);\r\n      await deleteDoc(transactionRef);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting transaction:', error);\r\n      throw new Error('Failed to delete transaction');\r\n    }\r\n  }\r\n\r\n  async getFinancialSummary(\r\n    period: TimePeriod,\r\n    customDateRange?: CustomDateRange,\r\n    accountFilter?: string\r\n  ): Promise<FinancialSummary> {\r\n    try {\r\n      // Get all transactions for the period\r\n      const transactions = await this.getTransactions();\r\n      \r\n      // Filter by account type if specified\r\n      let filteredTransactions = transactions;\r\n      if (accountFilter && accountFilter !== 'both') {\r\n        const accounts = await this.getAccounts();\r\n        const filteredAccounts = accounts.filter(account => {\r\n          if (accountFilter === 'personal') return !account.type.includes('BUSINESS');\r\n          if (accountFilter === 'business') return account.type.includes('BUSINESS');\r\n          return true;\r\n        });\r\n        const accountIds = filteredAccounts.map(account => account.id);\r\n        filteredTransactions = transactions.filter(tx => accountIds.includes(tx.accountId));\r\n      }\r\n      \r\n      const totalBalance = (await this.getAccounts()).reduce((sum, account) => sum + account.balance, 0);\r\n      \r\n      return calculateFinancialSummary(filteredTransactions, period, customDateRange, totalBalance);\r\n    } catch (error) {\r\n      console.error('Error calculating financial summary:', error);\r\n      throw new Error('Failed to calculate financial summary');\r\n    }\r\n  }\r\n\r\n  async searchTransactions(query: string): Promise<Transaction[]> {\r\n    try {\r\n      // Firestore doesn't support full-text search, so we'll fetch all transactions and filter client-side\r\n      // In production, you might want to use Algolia or similar for better search\r\n      const transactions = await this.getTransactions();\r\n      const lowerQuery = query.toLowerCase();\r\n      \r\n      return transactions.filter(transaction => \r\n        transaction.description.toLowerCase().includes(lowerQuery) ||\r\n        transaction.cleanMerchant.cleanName.toLowerCase().includes(lowerQuery) ||\r\n        transaction.category.toLowerCase().includes(lowerQuery) ||\r\n        transaction.tags.some(tag => tag.toLowerCase().includes(lowerQuery))\r\n      );\r\n    } catch (error) {\r\n      console.error('Error searching transactions:', error);\r\n      throw new Error('Failed to search transactions');\r\n    }\r\n  }\r\n\r\n  async getTransactionStats(accountId?: string): Promise<any> {\r\n    try {\r\n      const transactions = await this.getTransactions(accountId);\r\n      \r\n      const totalIncome = transactions\r\n        .filter(tx => tx.amount > 0)\r\n        .reduce((sum, tx) => sum + tx.amount, 0);\r\n      \r\n      const totalExpenses = transactions\r\n        .filter(tx => tx.amount < 0)\r\n        .reduce((sum, tx) => sum + Math.abs(tx.amount), 0);\r\n      \r\n      const categoryStats = transactions.reduce((stats, tx) => {\r\n        const category = tx.category;\r\n        if (!stats[category]) {\r\n          stats[category] = { count: 0, total: 0 };\r\n        }\r\n        stats[category].count++;\r\n        stats[category].total += Math.abs(tx.amount);\r\n        return stats;\r\n      }, {} as Record<string, { count: number; total: number }>);\r\n      \r\n      return {\r\n        totalTransactions: transactions.length,\r\n        totalIncome,\r\n        totalExpenses,\r\n        netAmount: totalIncome - totalExpenses,\r\n        categoryStats,\r\n        averageTransactionAmount: transactions.length > 0 \r\n          ? transactions.reduce((sum, tx) => sum + Math.abs(tx.amount), 0) / transactions.length \r\n          : 0\r\n      };\r\n    } catch (error) {\r\n      console.error('Error calculating transaction stats:', error);\r\n      throw new Error('Failed to calculate transaction stats');\r\n    }\r\n  }\r\n\r\n  // Real-time listeners for live data synchronization\r\n  subscribeToAccounts(callback: (accounts: Account[]) => void) {\r\n    const accountsRef = getUserAccountsCollection(this.userId);\r\n    return onSnapshot(accountsRef, (snapshot) => {\r\n      const accounts = snapshot.docs.map(doc => this.convertFirestoreToAccount(doc));\r\n      callback(accounts);\r\n    });\r\n  }\r\n\r\n  subscribeToTransactions(callback: (transactions: Transaction[]) => void, accountId?: string) {\r\n    const transactionsRef = getUserTransactionsCollection(this.userId);\r\n    const constraints: QueryConstraint[] = [orderBy('date', 'desc')];\r\n    \r\n    if (accountId) {\r\n      constraints.push(where('accountId', '==', accountId));\r\n    }\r\n    \r\n    const transactionsQuery = query(transactionsRef, ...constraints);\r\n    return onSnapshot(transactionsQuery, (snapshot) => {\r\n      const transactions = snapshot.docs.map(doc => this.convertFirestoreToTransaction(doc));\r\n      callback(transactions);\r\n    });\r\n  }\r\n}\r\n\r\nexport function createDataService(config: DataServiceConfig, userId?: string): DataService {\r\n  if (config.useMockData) {\r\n    return new MockDataService();\r\n  } else {\r\n    if (!userId) {\r\n      throw new Error('User ID is required for Firebase DataService');\r\n    }\r\n    return new FirebaseDataService(config, userId);\r\n  }\r\n}\r\n\r\n// Export classes for testing\r\nexport { MockDataService, FirebaseDataService };\r\n\r\n// Default export for convenience\r\nexport default createDataService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}