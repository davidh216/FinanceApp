{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useMemo, useState, useCallback } from 'react';\nimport { exportTransactions, exportSummary } from '../utils/exportUtils';\nexport const useCharts = (transactions, accounts, period, filters) => {\n  _s();\n  const [isExporting, setIsExporting] = useState(false);\n  const [exportError, setExportError] = useState(null);\n\n  // Calculate summary statistics\n  const summary = useMemo(() => {\n    const totalBalance = accounts.reduce((sum, account) => sum + account.balance, 0);\n    const periodTransactions = transactions.filter(t => {\n      // Apply basic period filtering (you can enhance this)\n      const transactionDate = new Date(t.date);\n      const now = new Date();\n      let startDate;\n      switch (period) {\n        case 'day':\n          startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n          break;\n        case 'week':\n          startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n          break;\n        case 'month':\n          startDate = new Date(now.getFullYear(), now.getMonth(), 1);\n          break;\n        case 'quarter':\n          const quarter = Math.floor(now.getMonth() / 3);\n          startDate = new Date(now.getFullYear(), quarter * 3, 1);\n          break;\n        case 'year':\n          startDate = new Date(now.getFullYear(), 0, 1);\n          break;\n        default:\n          startDate = new Date(now.getFullYear(), now.getMonth(), 1);\n      }\n      return transactionDate >= startDate && transactionDate <= now;\n    });\n    const totalIncome = periodTransactions.filter(t => t.amount > 0).reduce((sum, t) => sum + t.amount, 0);\n    const totalExpenses = Math.abs(periodTransactions.filter(t => t.amount < 0).reduce((sum, t) => sum + t.amount, 0));\n    const netFlow = totalIncome - totalExpenses;\n    const savingsRate = totalIncome > 0 ? netFlow / totalIncome * 100 : 0;\n\n    // Calculate top category\n    const categoryMap = new Map();\n    periodTransactions.filter(t => t.amount < 0).forEach(t => {\n      const category = t.category || 'Uncategorized';\n      categoryMap.set(category, (categoryMap.get(category) || 0) + Math.abs(t.amount));\n    });\n    const topCategory = Array.from(categoryMap.entries()).sort(([, a], [, b]) => b - a)[0] || ['None', 0];\n    return {\n      totalBalance,\n      totalIncome,\n      totalExpenses,\n      netFlow,\n      savingsRate,\n      topCategory: topCategory[0],\n      topCategoryAmount: topCategory[1]\n    };\n  }, [transactions, accounts, period]);\n\n  // Export functionality\n  const handleExportTransactions = useCallback(async () => {\n    setIsExporting(true);\n    setExportError(null);\n    try {\n      // Filter transactions based on current filters\n      let filteredTransactions = [...transactions];\n\n      // Apply basic filtering (you can enhance this based on your FilterOptions)\n      if (filters.dateRange) {\n        filteredTransactions = filteredTransactions.filter(t => {\n          const transactionDate = new Date(t.date);\n          const startDate = new Date(filters.dateRange.start);\n          const endDate = new Date(filters.dateRange.end);\n          return transactionDate >= startDate && transactionDate <= endDate;\n        });\n      }\n      if (filters.categories && filters.categories.length > 0) {\n        filteredTransactions = filteredTransactions.filter(t => filters.categories.includes(t.category));\n      }\n      const filename = `transactions_${period}_${new Date().toISOString().split('T')[0]}.csv`;\n      exportTransactions(filteredTransactions, filename);\n    } catch (error) {\n      setExportError(error instanceof Error ? error.message : 'Export failed');\n    } finally {\n      setIsExporting(false);\n    }\n  }, [transactions, filters, period]);\n  const handleExportSummary = useCallback(async () => {\n    setIsExporting(true);\n    setExportError(null);\n    try {\n      const summaryData = {\n        totalBalance: summary.totalBalance,\n        totalIncome: summary.totalIncome,\n        totalExpenses: summary.totalExpenses,\n        netSavings: summary.netFlow,\n        period: period\n      };\n      const filename = `financial_summary_${period}_${new Date().toISOString().split('T')[0]}.csv`;\n      exportSummary(summaryData, filename);\n    } catch (error) {\n      setExportError(error instanceof Error ? error.message : 'Export failed');\n    } finally {\n      setIsExporting(false);\n    }\n  }, [summary, period]);\n\n  // Chart data processing\n  const chartData = useMemo(() => {\n    return {\n      balanceTrend: {\n        transactions,\n        accounts,\n        period\n      },\n      incomeExpense: {\n        transactions,\n        period\n      },\n      categorySpending: {\n        transactions,\n        period\n      },\n      summary\n    };\n  }, [transactions, accounts, period, summary]);\n\n  // Refresh functionality\n  const refreshCharts = useCallback(() => {\n    // This would typically trigger a data refresh\n    // For now, we'll just return a promise that resolves immediately\n    return Promise.resolve();\n  }, []);\n  return {\n    chartData,\n    summary,\n    isExporting,\n    exportError,\n    handleExportTransactions,\n    handleExportSummary,\n    refreshCharts\n  };\n};\n_s(useCharts, \"u+prT6y3fJAZYxmvNPS6lXK53Ow=\");","map":{"version":3,"names":["useMemo","useState","useCallback","exportTransactions","exportSummary","useCharts","transactions","accounts","period","filters","_s","isExporting","setIsExporting","exportError","setExportError","summary","totalBalance","reduce","sum","account","balance","periodTransactions","filter","t","transactionDate","Date","date","now","startDate","getFullYear","getMonth","getDate","getTime","quarter","Math","floor","totalIncome","amount","totalExpenses","abs","netFlow","savingsRate","categoryMap","Map","forEach","category","set","get","topCategory","Array","from","entries","sort","a","b","topCategoryAmount","handleExportTransactions","filteredTransactions","dateRange","start","endDate","end","categories","length","includes","filename","toISOString","split","error","Error","message","handleExportSummary","summaryData","netSavings","chartData","balanceTrend","incomeExpense","categorySpending","refreshCharts","Promise","resolve"],"sources":["C:/Users/X2DHHWAN/Desktop/Finance-App/src/hooks/useCharts.ts"],"sourcesContent":["import { useMemo, useState, useCallback } from 'react';\r\nimport { Transaction, Account, TimePeriod, FilterOptions } from '../types/financial';\r\nimport { exportTransactions, exportSummary } from '../utils/exportUtils';\r\n\r\nexport interface ChartData {\r\n  balanceTrend: any;\r\n  incomeExpense: any;\r\n  categorySpending: any;\r\n  summary: {\r\n    totalBalance: number;\r\n    totalIncome: number;\r\n    totalExpenses: number;\r\n    netFlow: number;\r\n    savingsRate: number;\r\n    topCategory: string;\r\n    topCategoryAmount: number;\r\n  };\r\n}\r\n\r\nexport const useCharts = (\r\n  transactions: Transaction[],\r\n  accounts: Account[],\r\n  period: TimePeriod,\r\n  filters: FilterOptions\r\n) => {\r\n  const [isExporting, setIsExporting] = useState(false);\r\n  const [exportError, setExportError] = useState<string | null>(null);\r\n\r\n  // Calculate summary statistics\r\n  const summary = useMemo(() => {\r\n    const totalBalance = accounts.reduce((sum, account) => sum + account.balance, 0);\r\n    \r\n    const periodTransactions = transactions.filter(t => {\r\n      // Apply basic period filtering (you can enhance this)\r\n      const transactionDate = new Date(t.date);\r\n      const now = new Date();\r\n      let startDate: Date;\r\n      \r\n      switch (period) {\r\n        case 'day':\r\n          startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());\r\n          break;\r\n        case 'week':\r\n          startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\r\n          break;\r\n        case 'month':\r\n          startDate = new Date(now.getFullYear(), now.getMonth(), 1);\r\n          break;\r\n        case 'quarter':\r\n          const quarter = Math.floor(now.getMonth() / 3);\r\n          startDate = new Date(now.getFullYear(), quarter * 3, 1);\r\n          break;\r\n        case 'year':\r\n          startDate = new Date(now.getFullYear(), 0, 1);\r\n          break;\r\n        default:\r\n          startDate = new Date(now.getFullYear(), now.getMonth(), 1);\r\n      }\r\n      \r\n      return transactionDate >= startDate && transactionDate <= now;\r\n    });\r\n\r\n    const totalIncome = periodTransactions\r\n      .filter(t => t.amount > 0)\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n    \r\n    const totalExpenses = Math.abs(periodTransactions\r\n      .filter(t => t.amount < 0)\r\n      .reduce((sum, t) => sum + t.amount, 0));\r\n    \r\n    const netFlow = totalIncome - totalExpenses;\r\n    const savingsRate = totalIncome > 0 ? (netFlow / totalIncome) * 100 : 0;\r\n\r\n    // Calculate top category\r\n    const categoryMap = new Map<string, number>();\r\n    periodTransactions\r\n      .filter(t => t.amount < 0)\r\n      .forEach(t => {\r\n        const category = t.category || 'Uncategorized';\r\n        categoryMap.set(category, (categoryMap.get(category) || 0) + Math.abs(t.amount));\r\n      });\r\n\r\n    const topCategory = Array.from(categoryMap.entries())\r\n      .sort(([, a], [, b]) => b - a)[0] || ['None', 0];\r\n\r\n    return {\r\n      totalBalance,\r\n      totalIncome,\r\n      totalExpenses,\r\n      netFlow,\r\n      savingsRate,\r\n      topCategory: topCategory[0],\r\n      topCategoryAmount: topCategory[1],\r\n    };\r\n  }, [transactions, accounts, period]);\r\n\r\n  // Export functionality\r\n  const handleExportTransactions = useCallback(async () => {\r\n    setIsExporting(true);\r\n    setExportError(null);\r\n    \r\n    try {\r\n      // Filter transactions based on current filters\r\n      let filteredTransactions = [...transactions];\r\n      \r\n      // Apply basic filtering (you can enhance this based on your FilterOptions)\r\n      if (filters.dateRange) {\r\n        filteredTransactions = filteredTransactions.filter(t => {\r\n          const transactionDate = new Date(t.date);\r\n          const startDate = new Date(filters.dateRange!.start);\r\n          const endDate = new Date(filters.dateRange!.end);\r\n          return transactionDate >= startDate && transactionDate <= endDate;\r\n        });\r\n      }\r\n      \r\n      if (filters.categories && filters.categories.length > 0) {\r\n        filteredTransactions = filteredTransactions.filter(t =>\r\n          filters.categories!.includes(t.category)\r\n        );\r\n      }\r\n      \r\n      const filename = `transactions_${period}_${new Date().toISOString().split('T')[0]}.csv`;\r\n      exportTransactions(filteredTransactions, filename);\r\n    } catch (error) {\r\n      setExportError(error instanceof Error ? error.message : 'Export failed');\r\n    } finally {\r\n      setIsExporting(false);\r\n    }\r\n  }, [transactions, filters, period]);\r\n\r\n  const handleExportSummary = useCallback(async () => {\r\n    setIsExporting(true);\r\n    setExportError(null);\r\n    \r\n    try {\r\n      const summaryData = {\r\n        totalBalance: summary.totalBalance,\r\n        totalIncome: summary.totalIncome,\r\n        totalExpenses: summary.totalExpenses,\r\n        netSavings: summary.netFlow,\r\n        period: period,\r\n      };\r\n      \r\n      const filename = `financial_summary_${period}_${new Date().toISOString().split('T')[0]}.csv`;\r\n      exportSummary(summaryData, filename);\r\n    } catch (error) {\r\n      setExportError(error instanceof Error ? error.message : 'Export failed');\r\n    } finally {\r\n      setIsExporting(false);\r\n    }\r\n  }, [summary, period]);\r\n\r\n  // Chart data processing\r\n  const chartData = useMemo((): ChartData => {\r\n    return {\r\n      balanceTrend: {\r\n        transactions,\r\n        accounts,\r\n        period,\r\n      },\r\n      incomeExpense: {\r\n        transactions,\r\n        period,\r\n      },\r\n      categorySpending: {\r\n        transactions,\r\n        period,\r\n      },\r\n      summary,\r\n    };\r\n  }, [transactions, accounts, period, summary]);\r\n\r\n  // Refresh functionality\r\n  const refreshCharts = useCallback(() => {\r\n    // This would typically trigger a data refresh\r\n    // For now, we'll just return a promise that resolves immediately\r\n    return Promise.resolve();\r\n  }, []);\r\n\r\n  return {\r\n    chartData,\r\n    summary,\r\n    isExporting,\r\n    exportError,\r\n    handleExportTransactions,\r\n    handleExportSummary,\r\n    refreshCharts,\r\n  };\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}