{"ast":null,"code":"// Service Worker Registration Utility\n// Handles service worker installation, updates, and communication\n\nclass ServiceWorkerManager {\n  constructor() {\n    this.registration = null;\n    this.updateAvailable = false;\n  }\n  async register() {\n    if (!('serviceWorker' in navigator)) {\n      console.log('Service Worker not supported');\n      return false;\n    }\n    try {\n      this.registration = await navigator.serviceWorker.register('/sw.js', {\n        scope: '/'\n      });\n      console.log('Service Worker registered successfully:', this.registration);\n\n      // Listen for updates\n      this.registration.addEventListener('updatefound', () => {\n        const newWorker = this.registration.installing;\n        if (newWorker) {\n          newWorker.addEventListener('statechange', () => {\n            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n              this.updateAvailable = true;\n              this.notifyUpdateAvailable();\n            }\n          });\n        }\n      });\n\n      // Handle controller change\n      navigator.serviceWorker.addEventListener('controllerchange', () => {\n        console.log('Service Worker controller changed');\n        window.location.reload();\n      });\n\n      // Listen for messages from service worker\n      navigator.serviceWorker.addEventListener('message', event => {\n        this.handleServiceWorkerMessage(event.data);\n      });\n      return true;\n    } catch (error) {\n      console.error('Service Worker registration failed:', error);\n      return false;\n    }\n  }\n  handleServiceWorkerMessage(message) {\n    switch (message.type) {\n      case 'CACHE_UPDATED':\n        console.log('Cache updated:', message.payload);\n        break;\n      case 'SYNC_COMPLETED':\n        console.log('Background sync completed');\n        break;\n      case 'SYNC_FAILED':\n        console.error('Background sync failed:', message.payload);\n        break;\n      default:\n        console.log('Unknown service worker message:', message);\n    }\n  }\n  notifyUpdateAvailable() {\n    // You can implement a custom update notification here\n    // For now, we'll just log it\n    console.log('Service Worker update available');\n\n    // Example: Show a notification to the user\n    if ('Notification' in window && Notification.permission === 'granted') {\n      new Notification('FinanceApp Update Available', {\n        body: 'A new version is available. Click to update.',\n        icon: '/favicon.ico'\n      });\n    }\n  }\n  async update() {\n    if (this.registration && this.updateAvailable) {\n      await this.registration.update();\n    }\n  }\n  async skipWaiting() {\n    if (this.registration && this.registration.waiting) {\n      this.registration.waiting.postMessage({\n        type: 'SKIP_WAITING'\n      });\n    }\n  }\n  async unregister() {\n    if (this.registration) {\n      return await this.registration.unregister();\n    }\n    return false;\n  }\n  async getCacheNames() {\n    if (!('caches' in window)) {\n      return [];\n    }\n    return await caches.keys();\n  }\n  async clearAllCaches() {\n    if (!('caches' in window)) {\n      return;\n    }\n    const cacheNames = await caches.keys();\n    await Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)));\n  }\n  async clearCache(cacheName) {\n    if (!('caches' in window)) {\n      return false;\n    }\n    return await caches.delete(cacheName);\n  }\n  async getCacheSize(cacheName) {\n    if (!('caches' in window)) {\n      return 0;\n    }\n    const cache = await caches.open(cacheName);\n    const keys = await cache.keys();\n    return keys.length;\n  }\n  async requestNotificationPermission() {\n    if (!('Notification' in window)) {\n      return 'denied';\n    }\n    if (Notification.permission === 'default') {\n      return await Notification.requestPermission();\n    }\n    return Notification.permission;\n  }\n  async sendMessageToServiceWorker(message) {\n    if (this.registration && this.registration.active) {\n      this.registration.active.postMessage(message);\n    }\n  }\n  async triggerBackgroundSync(tag) {\n    if (!('serviceWorker' in navigator) || !('sync' in window)) {\n      return;\n    }\n    try {\n      await navigator.serviceWorker.ready;\n      await navigator.serviceWorker.sync.register(tag);\n    } catch (error) {\n      console.error('Background sync registration failed:', error);\n    }\n  }\n  isOnline() {\n    return navigator.onLine;\n  }\n  addOnlineListener(callback) {\n    window.addEventListener('online', callback);\n  }\n  addOfflineListener(callback) {\n    window.addEventListener('offline', callback);\n  }\n  removeOnlineListener(callback) {\n    window.removeEventListener('online', callback);\n  }\n  removeOfflineListener(callback) {\n    window.removeEventListener('offline', callback);\n  }\n}\n\n// Create singleton instance\nconst serviceWorkerManager = new ServiceWorkerManager();\n\n/**\r\n * Register service worker with development mode handling\r\n * Prevents cache issues during development by disabling SW in dev mode\r\n */\nexport const registerServiceWorker = async () => {\n  // Disable service worker in development mode to prevent cache issues\n  if (process.env.NODE_ENV === 'development') {\n    console.log('Service worker disabled in development mode to prevent cache issues');\n\n    // Unregister any existing service workers\n    if ('serviceWorker' in navigator) {\n      const registrations = await navigator.serviceWorker.getRegistrations();\n      for (const registration of registrations) {\n        await registration.unregister();\n        console.log('Unregistered existing service worker');\n      }\n    }\n    return;\n  }\n  if ('serviceWorker' in navigator) {\n    try {\n      const registration = await navigator.serviceWorker.register('/sw.js');\n      console.log('Service worker registered successfully:', registration);\n    } catch (error) {\n      console.error('Service worker registration failed:', error);\n    }\n  }\n};\nexport const updateServiceWorker = () => serviceWorkerManager.update();\nexport const skipWaiting = () => serviceWorkerManager.skipWaiting();\nexport const unregisterServiceWorker = () => serviceWorkerManager.unregister();\nexport const clearAllCaches = () => serviceWorkerManager.clearAllCaches();\nexport const getCacheNames = () => serviceWorkerManager.getCacheNames();\nexport const clearCache = cacheName => serviceWorkerManager.clearCache(cacheName);\nexport const getCacheSize = cacheName => serviceWorkerManager.getCacheSize(cacheName);\nexport const requestNotificationPermission = () => serviceWorkerManager.requestNotificationPermission();\nexport const sendMessageToServiceWorker = message => serviceWorkerManager.sendMessageToServiceWorker(message);\nexport const triggerBackgroundSync = tag => serviceWorkerManager.triggerBackgroundSync(tag);\nexport const isOnline = () => serviceWorkerManager.isOnline();\nexport const addOnlineListener = callback => serviceWorkerManager.addOnlineListener(callback);\nexport const addOfflineListener = callback => serviceWorkerManager.addOfflineListener(callback);\nexport const removeOnlineListener = callback => serviceWorkerManager.removeOnlineListener(callback);\nexport const removeOfflineListener = callback => serviceWorkerManager.removeOfflineListener(callback);\n\n// Export the manager instance for advanced usage\nexport default serviceWorkerManager;","map":{"version":3,"names":["ServiceWorkerManager","constructor","registration","updateAvailable","register","navigator","console","log","serviceWorker","scope","addEventListener","newWorker","installing","state","controller","notifyUpdateAvailable","window","location","reload","event","handleServiceWorkerMessage","data","error","message","type","payload","Notification","permission","body","icon","update","skipWaiting","waiting","postMessage","unregister","getCacheNames","caches","keys","clearAllCaches","cacheNames","Promise","all","map","cacheName","delete","clearCache","getCacheSize","cache","open","length","requestNotificationPermission","requestPermission","sendMessageToServiceWorker","active","triggerBackgroundSync","tag","ready","sync","isOnline","onLine","addOnlineListener","callback","addOfflineListener","removeOnlineListener","removeEventListener","removeOfflineListener","serviceWorkerManager","registerServiceWorker","process","env","NODE_ENV","registrations","getRegistrations","updateServiceWorker","unregisterServiceWorker"],"sources":["C:/Users/X2DHHWAN/Desktop/Finance-App/src/utils/serviceWorker.ts"],"sourcesContent":["// Service Worker Registration Utility\r\n// Handles service worker installation, updates, and communication\r\n\r\ninterface ServiceWorkerMessage {\r\n  type: string;\r\n  payload?: any;\r\n}\r\n\r\nclass ServiceWorkerManager {\r\n  private registration: ServiceWorkerRegistration | null = null;\r\n  private updateAvailable = false;\r\n\r\n  async register(): Promise<boolean> {\r\n    if (!('serviceWorker' in navigator)) {\r\n      console.log('Service Worker not supported');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      this.registration = await navigator.serviceWorker.register('/sw.js', {\r\n        scope: '/',\r\n      });\r\n\r\n      console.log('Service Worker registered successfully:', this.registration);\r\n\r\n      // Listen for updates\r\n      this.registration.addEventListener('updatefound', () => {\r\n        const newWorker = this.registration!.installing;\r\n        if (newWorker) {\r\n          newWorker.addEventListener('statechange', () => {\r\n            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\r\n              this.updateAvailable = true;\r\n              this.notifyUpdateAvailable();\r\n            }\r\n          });\r\n        }\r\n      });\r\n\r\n      // Handle controller change\r\n      navigator.serviceWorker.addEventListener('controllerchange', () => {\r\n        console.log('Service Worker controller changed');\r\n        window.location.reload();\r\n      });\r\n\r\n      // Listen for messages from service worker\r\n      navigator.serviceWorker.addEventListener('message', (event) => {\r\n        this.handleServiceWorkerMessage(event.data);\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Service Worker registration failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private handleServiceWorkerMessage(message: ServiceWorkerMessage) {\r\n    switch (message.type) {\r\n      case 'CACHE_UPDATED':\r\n        console.log('Cache updated:', message.payload);\r\n        break;\r\n      case 'SYNC_COMPLETED':\r\n        console.log('Background sync completed');\r\n        break;\r\n      case 'SYNC_FAILED':\r\n        console.error('Background sync failed:', message.payload);\r\n        break;\r\n      default:\r\n        console.log('Unknown service worker message:', message);\r\n    }\r\n  }\r\n\r\n  private notifyUpdateAvailable() {\r\n    // You can implement a custom update notification here\r\n    // For now, we'll just log it\r\n    console.log('Service Worker update available');\r\n    \r\n    // Example: Show a notification to the user\r\n    if ('Notification' in window && Notification.permission === 'granted') {\r\n      new Notification('FinanceApp Update Available', {\r\n        body: 'A new version is available. Click to update.',\r\n        icon: '/favicon.ico',\r\n      });\r\n    }\r\n  }\r\n\r\n  async update(): Promise<void> {\r\n    if (this.registration && this.updateAvailable) {\r\n      await this.registration.update();\r\n    }\r\n  }\r\n\r\n  async skipWaiting(): Promise<void> {\r\n    if (this.registration && this.registration.waiting) {\r\n      this.registration.waiting.postMessage({ type: 'SKIP_WAITING' });\r\n    }\r\n  }\r\n\r\n  async unregister(): Promise<boolean> {\r\n    if (this.registration) {\r\n      return await this.registration.unregister();\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async getCacheNames(): Promise<string[]> {\r\n    if (!('caches' in window)) {\r\n      return [];\r\n    }\r\n    return await caches.keys();\r\n  }\r\n\r\n  async clearAllCaches(): Promise<void> {\r\n    if (!('caches' in window)) {\r\n      return;\r\n    }\r\n    \r\n    const cacheNames = await caches.keys();\r\n    await Promise.all(\r\n      cacheNames.map(cacheName => caches.delete(cacheName))\r\n    );\r\n  }\r\n\r\n  async clearCache(cacheName: string): Promise<boolean> {\r\n    if (!('caches' in window)) {\r\n      return false;\r\n    }\r\n    return await caches.delete(cacheName);\r\n  }\r\n\r\n  async getCacheSize(cacheName: string): Promise<number> {\r\n    if (!('caches' in window)) {\r\n      return 0;\r\n    }\r\n    \r\n    const cache = await caches.open(cacheName);\r\n    const keys = await cache.keys();\r\n    return keys.length;\r\n  }\r\n\r\n  async requestNotificationPermission(): Promise<NotificationPermission> {\r\n    if (!('Notification' in window)) {\r\n      return 'denied';\r\n    }\r\n\r\n    if (Notification.permission === 'default') {\r\n      return await Notification.requestPermission();\r\n    }\r\n\r\n    return Notification.permission;\r\n  }\r\n\r\n  async sendMessageToServiceWorker(message: ServiceWorkerMessage): Promise<void> {\r\n    if (this.registration && this.registration.active) {\r\n      this.registration.active.postMessage(message);\r\n    }\r\n  }\r\n\r\n  async triggerBackgroundSync(tag: string): Promise<void> {\r\n    if (!('serviceWorker' in navigator) || !('sync' in window)) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      await navigator.serviceWorker.ready;\r\n      await (navigator.serviceWorker as any).sync.register(tag);\r\n    } catch (error) {\r\n      console.error('Background sync registration failed:', error);\r\n    }\r\n  }\r\n\r\n  isOnline(): boolean {\r\n    return navigator.onLine;\r\n  }\r\n\r\n  addOnlineListener(callback: () => void): void {\r\n    window.addEventListener('online', callback);\r\n  }\r\n\r\n  addOfflineListener(callback: () => void): void {\r\n    window.addEventListener('offline', callback);\r\n  }\r\n\r\n  removeOnlineListener(callback: () => void): void {\r\n    window.removeEventListener('online', callback);\r\n  }\r\n\r\n  removeOfflineListener(callback: () => void): void {\r\n    window.removeEventListener('offline', callback);\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nconst serviceWorkerManager = new ServiceWorkerManager();\r\n\r\n/**\r\n * Register service worker with development mode handling\r\n * Prevents cache issues during development by disabling SW in dev mode\r\n */\r\nexport const registerServiceWorker = async () => {\r\n  // Disable service worker in development mode to prevent cache issues\r\n  if (process.env.NODE_ENV === 'development') {\r\n    console.log('Service worker disabled in development mode to prevent cache issues');\r\n    \r\n    // Unregister any existing service workers\r\n    if ('serviceWorker' in navigator) {\r\n      const registrations = await navigator.serviceWorker.getRegistrations();\r\n      for (const registration of registrations) {\r\n        await registration.unregister();\r\n        console.log('Unregistered existing service worker');\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  if ('serviceWorker' in navigator) {\r\n    try {\r\n      const registration = await navigator.serviceWorker.register('/sw.js');\r\n      console.log('Service worker registered successfully:', registration);\r\n    } catch (error) {\r\n      console.error('Service worker registration failed:', error);\r\n    }\r\n  }\r\n};\r\nexport const updateServiceWorker = () => serviceWorkerManager.update();\r\nexport const skipWaiting = () => serviceWorkerManager.skipWaiting();\r\nexport const unregisterServiceWorker = () => serviceWorkerManager.unregister();\r\nexport const clearAllCaches = () => serviceWorkerManager.clearAllCaches();\r\nexport const getCacheNames = () => serviceWorkerManager.getCacheNames();\r\nexport const clearCache = (cacheName: string) => serviceWorkerManager.clearCache(cacheName);\r\nexport const getCacheSize = (cacheName: string) => serviceWorkerManager.getCacheSize(cacheName);\r\nexport const requestNotificationPermission = () => serviceWorkerManager.requestNotificationPermission();\r\nexport const sendMessageToServiceWorker = (message: ServiceWorkerMessage) => serviceWorkerManager.sendMessageToServiceWorker(message);\r\nexport const triggerBackgroundSync = (tag: string) => serviceWorkerManager.triggerBackgroundSync(tag);\r\nexport const isOnline = () => serviceWorkerManager.isOnline();\r\nexport const addOnlineListener = (callback: () => void) => serviceWorkerManager.addOnlineListener(callback);\r\nexport const addOfflineListener = (callback: () => void) => serviceWorkerManager.addOfflineListener(callback);\r\nexport const removeOnlineListener = (callback: () => void) => serviceWorkerManager.removeOnlineListener(callback);\r\nexport const removeOfflineListener = (callback: () => void) => serviceWorkerManager.removeOfflineListener(callback);\r\n\r\n// Export the manager instance for advanced usage\r\nexport default serviceWorkerManager; "],"mappings":"AAAA;AACA;;AAOA,MAAMA,oBAAoB,CAAC;EAAAC,YAAA;IAAA,KACjBC,YAAY,GAAqC,IAAI;IAAA,KACrDC,eAAe,GAAG,KAAK;EAAA;EAE/B,MAAMC,QAAQA,CAAA,EAAqB;IACjC,IAAI,EAAE,eAAe,IAAIC,SAAS,CAAC,EAAE;MACnCC,OAAO,CAACC,GAAG,CAAC,8BAA8B,CAAC;MAC3C,OAAO,KAAK;IACd;IAEA,IAAI;MACF,IAAI,CAACL,YAAY,GAAG,MAAMG,SAAS,CAACG,aAAa,CAACJ,QAAQ,CAAC,QAAQ,EAAE;QACnEK,KAAK,EAAE;MACT,CAAC,CAAC;MAEFH,OAAO,CAACC,GAAG,CAAC,yCAAyC,EAAE,IAAI,CAACL,YAAY,CAAC;;MAEzE;MACA,IAAI,CAACA,YAAY,CAACQ,gBAAgB,CAAC,aAAa,EAAE,MAAM;QACtD,MAAMC,SAAS,GAAG,IAAI,CAACT,YAAY,CAAEU,UAAU;QAC/C,IAAID,SAAS,EAAE;UACbA,SAAS,CAACD,gBAAgB,CAAC,aAAa,EAAE,MAAM;YAC9C,IAAIC,SAAS,CAACE,KAAK,KAAK,WAAW,IAAIR,SAAS,CAACG,aAAa,CAACM,UAAU,EAAE;cACzE,IAAI,CAACX,eAAe,GAAG,IAAI;cAC3B,IAAI,CAACY,qBAAqB,CAAC,CAAC;YAC9B;UACF,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;;MAEF;MACAV,SAAS,CAACG,aAAa,CAACE,gBAAgB,CAAC,kBAAkB,EAAE,MAAM;QACjEJ,OAAO,CAACC,GAAG,CAAC,mCAAmC,CAAC;QAChDS,MAAM,CAACC,QAAQ,CAACC,MAAM,CAAC,CAAC;MAC1B,CAAC,CAAC;;MAEF;MACAb,SAAS,CAACG,aAAa,CAACE,gBAAgB,CAAC,SAAS,EAAGS,KAAK,IAAK;QAC7D,IAAI,CAACC,0BAA0B,CAACD,KAAK,CAACE,IAAI,CAAC;MAC7C,CAAC,CAAC;MAEF,OAAO,IAAI;IACb,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdhB,OAAO,CAACgB,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;MAC3D,OAAO,KAAK;IACd;EACF;EAEQF,0BAA0BA,CAACG,OAA6B,EAAE;IAChE,QAAQA,OAAO,CAACC,IAAI;MAClB,KAAK,eAAe;QAClBlB,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEgB,OAAO,CAACE,OAAO,CAAC;QAC9C;MACF,KAAK,gBAAgB;QACnBnB,OAAO,CAACC,GAAG,CAAC,2BAA2B,CAAC;QACxC;MACF,KAAK,aAAa;QAChBD,OAAO,CAACgB,KAAK,CAAC,yBAAyB,EAAEC,OAAO,CAACE,OAAO,CAAC;QACzD;MACF;QACEnB,OAAO,CAACC,GAAG,CAAC,iCAAiC,EAAEgB,OAAO,CAAC;IAC3D;EACF;EAEQR,qBAAqBA,CAAA,EAAG;IAC9B;IACA;IACAT,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAC;;IAE9C;IACA,IAAI,cAAc,IAAIS,MAAM,IAAIU,YAAY,CAACC,UAAU,KAAK,SAAS,EAAE;MACrE,IAAID,YAAY,CAAC,6BAA6B,EAAE;QAC9CE,IAAI,EAAE,8CAA8C;QACpDC,IAAI,EAAE;MACR,CAAC,CAAC;IACJ;EACF;EAEA,MAAMC,MAAMA,CAAA,EAAkB;IAC5B,IAAI,IAAI,CAAC5B,YAAY,IAAI,IAAI,CAACC,eAAe,EAAE;MAC7C,MAAM,IAAI,CAACD,YAAY,CAAC4B,MAAM,CAAC,CAAC;IAClC;EACF;EAEA,MAAMC,WAAWA,CAAA,EAAkB;IACjC,IAAI,IAAI,CAAC7B,YAAY,IAAI,IAAI,CAACA,YAAY,CAAC8B,OAAO,EAAE;MAClD,IAAI,CAAC9B,YAAY,CAAC8B,OAAO,CAACC,WAAW,CAAC;QAAET,IAAI,EAAE;MAAe,CAAC,CAAC;IACjE;EACF;EAEA,MAAMU,UAAUA,CAAA,EAAqB;IACnC,IAAI,IAAI,CAAChC,YAAY,EAAE;MACrB,OAAO,MAAM,IAAI,CAACA,YAAY,CAACgC,UAAU,CAAC,CAAC;IAC7C;IACA,OAAO,KAAK;EACd;EAEA,MAAMC,aAAaA,CAAA,EAAsB;IACvC,IAAI,EAAE,QAAQ,IAAInB,MAAM,CAAC,EAAE;MACzB,OAAO,EAAE;IACX;IACA,OAAO,MAAMoB,MAAM,CAACC,IAAI,CAAC,CAAC;EAC5B;EAEA,MAAMC,cAAcA,CAAA,EAAkB;IACpC,IAAI,EAAE,QAAQ,IAAItB,MAAM,CAAC,EAAE;MACzB;IACF;IAEA,MAAMuB,UAAU,GAAG,MAAMH,MAAM,CAACC,IAAI,CAAC,CAAC;IACtC,MAAMG,OAAO,CAACC,GAAG,CACfF,UAAU,CAACG,GAAG,CAACC,SAAS,IAAIP,MAAM,CAACQ,MAAM,CAACD,SAAS,CAAC,CACtD,CAAC;EACH;EAEA,MAAME,UAAUA,CAACF,SAAiB,EAAoB;IACpD,IAAI,EAAE,QAAQ,IAAI3B,MAAM,CAAC,EAAE;MACzB,OAAO,KAAK;IACd;IACA,OAAO,MAAMoB,MAAM,CAACQ,MAAM,CAACD,SAAS,CAAC;EACvC;EAEA,MAAMG,YAAYA,CAACH,SAAiB,EAAmB;IACrD,IAAI,EAAE,QAAQ,IAAI3B,MAAM,CAAC,EAAE;MACzB,OAAO,CAAC;IACV;IAEA,MAAM+B,KAAK,GAAG,MAAMX,MAAM,CAACY,IAAI,CAACL,SAAS,CAAC;IAC1C,MAAMN,IAAI,GAAG,MAAMU,KAAK,CAACV,IAAI,CAAC,CAAC;IAC/B,OAAOA,IAAI,CAACY,MAAM;EACpB;EAEA,MAAMC,6BAA6BA,CAAA,EAAoC;IACrE,IAAI,EAAE,cAAc,IAAIlC,MAAM,CAAC,EAAE;MAC/B,OAAO,QAAQ;IACjB;IAEA,IAAIU,YAAY,CAACC,UAAU,KAAK,SAAS,EAAE;MACzC,OAAO,MAAMD,YAAY,CAACyB,iBAAiB,CAAC,CAAC;IAC/C;IAEA,OAAOzB,YAAY,CAACC,UAAU;EAChC;EAEA,MAAMyB,0BAA0BA,CAAC7B,OAA6B,EAAiB;IAC7E,IAAI,IAAI,CAACrB,YAAY,IAAI,IAAI,CAACA,YAAY,CAACmD,MAAM,EAAE;MACjD,IAAI,CAACnD,YAAY,CAACmD,MAAM,CAACpB,WAAW,CAACV,OAAO,CAAC;IAC/C;EACF;EAEA,MAAM+B,qBAAqBA,CAACC,GAAW,EAAiB;IACtD,IAAI,EAAE,eAAe,IAAIlD,SAAS,CAAC,IAAI,EAAE,MAAM,IAAIW,MAAM,CAAC,EAAE;MAC1D;IACF;IAEA,IAAI;MACF,MAAMX,SAAS,CAACG,aAAa,CAACgD,KAAK;MACnC,MAAOnD,SAAS,CAACG,aAAa,CAASiD,IAAI,CAACrD,QAAQ,CAACmD,GAAG,CAAC;IAC3D,CAAC,CAAC,OAAOjC,KAAK,EAAE;MACdhB,OAAO,CAACgB,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;IAC9D;EACF;EAEAoC,QAAQA,CAAA,EAAY;IAClB,OAAOrD,SAAS,CAACsD,MAAM;EACzB;EAEAC,iBAAiBA,CAACC,QAAoB,EAAQ;IAC5C7C,MAAM,CAACN,gBAAgB,CAAC,QAAQ,EAAEmD,QAAQ,CAAC;EAC7C;EAEAC,kBAAkBA,CAACD,QAAoB,EAAQ;IAC7C7C,MAAM,CAACN,gBAAgB,CAAC,SAAS,EAAEmD,QAAQ,CAAC;EAC9C;EAEAE,oBAAoBA,CAACF,QAAoB,EAAQ;IAC/C7C,MAAM,CAACgD,mBAAmB,CAAC,QAAQ,EAAEH,QAAQ,CAAC;EAChD;EAEAI,qBAAqBA,CAACJ,QAAoB,EAAQ;IAChD7C,MAAM,CAACgD,mBAAmB,CAAC,SAAS,EAAEH,QAAQ,CAAC;EACjD;AACF;;AAEA;AACA,MAAMK,oBAAoB,GAAG,IAAIlE,oBAAoB,CAAC,CAAC;;AAEvD;AACA;AACA;AACA;AACA,OAAO,MAAMmE,qBAAqB,GAAG,MAAAA,CAAA,KAAY;EAC/C;EACA,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;IAC1ChE,OAAO,CAACC,GAAG,CAAC,qEAAqE,CAAC;;IAElF;IACA,IAAI,eAAe,IAAIF,SAAS,EAAE;MAChC,MAAMkE,aAAa,GAAG,MAAMlE,SAAS,CAACG,aAAa,CAACgE,gBAAgB,CAAC,CAAC;MACtE,KAAK,MAAMtE,YAAY,IAAIqE,aAAa,EAAE;QACxC,MAAMrE,YAAY,CAACgC,UAAU,CAAC,CAAC;QAC/B5B,OAAO,CAACC,GAAG,CAAC,sCAAsC,CAAC;MACrD;IACF;IACA;EACF;EAEA,IAAI,eAAe,IAAIF,SAAS,EAAE;IAChC,IAAI;MACF,MAAMH,YAAY,GAAG,MAAMG,SAAS,CAACG,aAAa,CAACJ,QAAQ,CAAC,QAAQ,CAAC;MACrEE,OAAO,CAACC,GAAG,CAAC,yCAAyC,EAAEL,YAAY,CAAC;IACtE,CAAC,CAAC,OAAOoB,KAAK,EAAE;MACdhB,OAAO,CAACgB,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;IAC7D;EACF;AACF,CAAC;AACD,OAAO,MAAMmD,mBAAmB,GAAGA,CAAA,KAAMP,oBAAoB,CAACpC,MAAM,CAAC,CAAC;AACtE,OAAO,MAAMC,WAAW,GAAGA,CAAA,KAAMmC,oBAAoB,CAACnC,WAAW,CAAC,CAAC;AACnE,OAAO,MAAM2C,uBAAuB,GAAGA,CAAA,KAAMR,oBAAoB,CAAChC,UAAU,CAAC,CAAC;AAC9E,OAAO,MAAMI,cAAc,GAAGA,CAAA,KAAM4B,oBAAoB,CAAC5B,cAAc,CAAC,CAAC;AACzE,OAAO,MAAMH,aAAa,GAAGA,CAAA,KAAM+B,oBAAoB,CAAC/B,aAAa,CAAC,CAAC;AACvE,OAAO,MAAMU,UAAU,GAAIF,SAAiB,IAAKuB,oBAAoB,CAACrB,UAAU,CAACF,SAAS,CAAC;AAC3F,OAAO,MAAMG,YAAY,GAAIH,SAAiB,IAAKuB,oBAAoB,CAACpB,YAAY,CAACH,SAAS,CAAC;AAC/F,OAAO,MAAMO,6BAA6B,GAAGA,CAAA,KAAMgB,oBAAoB,CAAChB,6BAA6B,CAAC,CAAC;AACvG,OAAO,MAAME,0BAA0B,GAAI7B,OAA6B,IAAK2C,oBAAoB,CAACd,0BAA0B,CAAC7B,OAAO,CAAC;AACrI,OAAO,MAAM+B,qBAAqB,GAAIC,GAAW,IAAKW,oBAAoB,CAACZ,qBAAqB,CAACC,GAAG,CAAC;AACrG,OAAO,MAAMG,QAAQ,GAAGA,CAAA,KAAMQ,oBAAoB,CAACR,QAAQ,CAAC,CAAC;AAC7D,OAAO,MAAME,iBAAiB,GAAIC,QAAoB,IAAKK,oBAAoB,CAACN,iBAAiB,CAACC,QAAQ,CAAC;AAC3G,OAAO,MAAMC,kBAAkB,GAAID,QAAoB,IAAKK,oBAAoB,CAACJ,kBAAkB,CAACD,QAAQ,CAAC;AAC7G,OAAO,MAAME,oBAAoB,GAAIF,QAAoB,IAAKK,oBAAoB,CAACH,oBAAoB,CAACF,QAAQ,CAAC;AACjH,OAAO,MAAMI,qBAAqB,GAAIJ,QAAoB,IAAKK,oBAAoB,CAACD,qBAAqB,CAACJ,QAAQ,CAAC;;AAEnH;AACA,eAAeK,oBAAoB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}